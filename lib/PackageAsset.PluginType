#!/bin/bash


# Library
# Each PackageAsset Plugin instance introduces a new type of asset that can be distributed in software packages. PackageAsset Plugins
# are used on developer hosts to build and maintain software packages. The bg-dev tool will recognize all PackageAsset Plugins installed on
# the host to form the set of available asset types.
#
# This Plugin library provides logically static public interfaces that can operate on the entire set of installed PackageAsset
# instances. These static functions either iterate all the instances calling their corresponding non-static methods or they locate
# the instance that handles a particular assetType and calls that instance's non-static members
#
# Asset Manifest Data Flow:
# When a project is installed, its project local manifest is used to iterate and install the project's assets to the host system.
# In an actual install, the installed assets are added to the host's system wide manifest file at /var/lib/bg-core/manifest. When
# a developer virtually installs a project folder, the project's assets are added to a virtually installed manifest file which is
# typically located in the top sandbox folder which is virtually installed (<sandboxFolder>/.bglocal/hostmanifest).
# The format of a project local manifest file and a host manifest file is the same but the data for the path is different. A project
# local manifest file has paths relative to the project root folder whereas a host manifest file has absolute paths to where the
# asset is located on the host. A virtually installed host manifest file has absolute paths to the files in the project folder that
# was virtually installed.
#
# Creating a new AssetType:
# Use "bg-dev assets addNewAsset plugin.PackageAsset -- myNewAssetName" to create a new asset type provided by a package project.
# A file plugins/myNewAssetName.PackageAsset will be created with typicall functions created for the three behaviors. Edit those
# functions appropriately.
#
# When the package that contains myNewAssetName.PackageAsset is installed on a host, any project developed on that host will be able
# to add myNewAssetName assets. Adding an asset from a plugin will add a dev time dependency on the the package that provides the
# plugin to the project where the plugin was added. After cloning a project you can install its dev time dependent pacakges.
# TODO: document the command to install dev time dependents here after its created.
#
# Public Interface:
# Static Interface...
#    static::PackageAsset::addNewAsset : identify the PackageAsset instance and calls its addNew method.
#    static::PackageAsset::findAllProjectAssets   : iterate all of the PackageAsset instances and call their $obj.find mehods to give them each a chance to scan
#                      the project's folder tree for assets.
#    static::PackageAsset::installAssets : iterate the local project manifest of assets and for each assetType found, call the correponding's PackageAsset
#                      instance $obj.install method to install the assets of that assetType.
#    static::PackageAsset::uninstallAssets  : invoke the uninstall script that was created during the last install to remove the older asset list
#
# Non-static Iinterface...
#    $obj.find    : scan the PWD and subfolders for files that match the asset type and print the results to stdout in the format of
#                   the manifest file.
#    $obj.install <file1> [... <fileN>]    : install each asset passed in the cmd line to the file system rooted at $DESTDIR
#                 This behavior has three responsibilities.
#                    1) copy the asset file(s) to the correct sub folder under the path pointed to by $DESTDIR
#                    2) append to the $HOSTMANIFEST. This copies the line from the project manifest to the HOSTMANIFEST, changing
#                       the path to the absolute path in $DESTDIR.
#    $obj.create <name>  : create a new assetName in a project of type assetType. Typically it expands a template into the correct
#                       project subfolder by converting <name> into the right foom (e.g. adding an extension like <name>.template)
#
# Writing a PackageAsset Plugin:
# Refer to man(7) bashPlugins for information how how to write plugins in general.
#
# Use "bg-dev assets addNewAsset plugin.PackageAsset -- myNewAssetName" to create a new gneric PackageAsset that can then be modified
# to suite your needs.  The plugin file that it creates complies with the structure described below.
#
# Required Attributes:
# The pluign author must provide these attributes in the DeclarePlugin call.
#    cmd_find    : a command that scans a project folder and identifies any assets of this type contained in the project.
#    cmd_install : a command that installs a particular asset of this type into the target's file system.
#    cmd_addNewAsset  : a command that adds a new asset of this type to a project folder.
# Note: 2022-03: the original non-static methods were written before I made the PackageAsset plugin so they are written to find
#       the non-static member functions by looking for function (or cmds) that follow a naming convention. Sometimes, these methods
#       are not invoked via the plugin invoke which uses hese attributes but instead rely on the method names complying with the
#       naming standard.
#
# Optional Attributes:
#    goal        : a brief description about the asset type it represents. Should be one short line.
#    description : more detailed information about the asset type.
#
# Example:
#     #!/bin/bash
#
#     DeclarePlugin PackageAsset foo "
#     	cmd_find:    bgAssetFind_foo
#     	cmd_install: bgAssetInstall_foo
#     	cmd_addNewAsset:  bgAssetAddNewAsset_foo
#     "
#
#
#     function bgAssetFind_foo() {
#     	static::PackageAsset::_findAssetsOfType --rmSuffix=""          "foo"           -R  -- ./*                       -type f  -name "*.foo"
#     }
#     function bgAssetInstall_foo() {
#     	static::PackageAsset::_installFilesToDst --flat   ""             "/usr/share/foo"            "$@"
#     }
#     function bgAssetAddNewAsset_foo() {
#     	local assetName="$1"
#     	local templateFile; templateFind -R templateFile foo
#     	templateExpand "$templateFile" "./lib/$assetName.foo"
#     }
#
# static::PackageAsset::_findAssetsOfType and static::PackageAsset::_installFilesToDst are helper functions provided in the PackageAsset plugin library.
#
# See Also:
#    man(3) bg-dev-assets

import bg_manifest.sh ;$L1;$L2
import bg_plugins.sh ;$L1;$L2

manifestProjPath=".bglocal/manifest"

DeclarePluginType PackageAsset "
	columns: name(-18) cmd_find(-18) cmd_install(-18) cmd_addNewAsset(-18)  goal tags description
	keyCol: name
	requiredCols: cmd_find cmd_install cmd_addNewAsset
	defDisplayCols: name goal
	description: A PackageAsset plugin defines a type of asset that can be distributed via software packages.
	 See man(7) PackageAsset.PluginType
"

#################################################################################################################################
### Virtual plugin members functions that should be implemented by PackageAsset plugins


function PackageAsset::__construct()
{
	:
}

function PackageAsset::find()
{
	$_this.invoke "cmd_find" "$@"
}

function PackageAsset::install()
{
	$_this.invoke "cmd_install" "$@"
}

function PackageAsset::addNewAsset()
{
	# TODO: should we put a default implementation here? the template for new assetTypes has one but that means we have to update all of them if the algoritm cahnges
	$_this.invoke "cmd_addNewAsset" "$@"
}

#################################################################################################################################
### Static API that bg-dev tools use

# usage: static::PackageAsset::addNewAsset <assetType> <assetName>
# This finds the function to call to invoke the addNewAsset behavior for <assetType>. Logically, this should just instanciate the
# PackageAsset plugin for <assetType> and call addNewAsset, however, some assetType are builtin and do not have a PackageAsset plugin.
function static::PackageAsset::addNewAsset()
{
	while [ $# -gt 0 ]; do case $1 in
		*)  bgOptionsEndLoop "$@" && break; set -- "${bgOptionsExpandedOpts[@]}"; esac; shift;
	done
	local assetType="$1"; shift; assertNotEmpty assetType
	local assetName="$1"; shift; assertNotEmpty assetName

	case $assetType in
		cmd|cmd.*)            static::PackageAsset::createNewAssetFromTemplate --perm="..x ..x ..x" "$assetType"  "$assetName"       "./$assetName" ;;
		lib|lib.*)            static::PackageAsset::createNewAssetFromTemplate                      "$assetType"  "$assetName"       "./lib/$assetName" ;;
		cron|cron.*)          static::PackageAsset::createNewAssetFromTemplate                      "$assetType"  "$assetName"       "./cron/$assetName" ;;
		sysDInit|sysDInit.*)  static::PackageAsset::createNewAssetFromTemplate                      "$assetType"  "$assetName"       "./init/$assetName" ;;
		template|template.*)  static::PackageAsset::createNewAssetFromTemplate                      "$assetType"  "$assetName"       "./templates/$assetName" ;;
		unitTest|unitTest.*)  static::PackageAsset::createNewAssetFromTemplate --perm="..x ..x ..x" "$assetType"  "${assetName%.ut}" "./unitTests/${assetName%.ut}.ut" ;;

		plugin.*)
			local pluginType="${assetType#plugin.}"
			local -n pt; $Plugin::get PluginType:$pluginType pt
			$pt::addNewAsset "$assetName"
			;;

		*)	import bg_template.sh  ;$L1;$L2

			# look for a helper...
			local helperFnName
			static::PackageAsset::assetGetFirstHelperCmd -R helperFnName  "bg-dev-addNew" "bgAssetAddNew" "$type"

			if [ "$helperFnName" ]; then
				$helperFnName "$type" "${files[@]}"

			# first, use a PackageAsset plugin for this assetType if there is one.
			elif [ "$(manifestGet -o'$4' "plugin" "PackageAsset:$assetType")" ]; then
				local -n assetP; $Plugin::get PackageAsset:$assetType assetP
				$assetP.addNewAsset "$assetName"

			# second, if there is a template with the right name use it. Note that we dont know where in the project to put the
			# new asset so we put it at the root
			elif [ "$(manifestGet -o'$4' "template.*" "newAsset.$assetType")" ]; then
				static::PackageAsset::createNewAssetFromTemplate "$assetType"  "$assetName" "./$assetName"

			# nothing else to try so error out...
			else
				assertError -v assetType -v assetName "
					Could not create a new asset of this type because neither a plugin named 'PackageAsset:$assetType'
					nor a template named 'newAsset.${assetType}' were found installed on this host.
				"
			fi
			;;
	esac
}

# usage: static::PackageAsset::addAssetToManifest <assetType> <assetName> <filePath>
# This is used in ::addNewAsset functions to immediately update the existing manifest so that the user does not need to run the
# full vinstall after adding a single asset. Its optional but provides a better development experiance.
# Note that this function does not pass in the <pkgName> because we assume that is a global var because we are running under bg-dev
function static::PackageAsset::addAssetToManifest()
{
	local assetType="$1"
	local assetName="$2"
	local filename="$3"

	printf "%-20s %-20s %-20s %s\n" "${pkgName:---}" "${assetType:---}"  "${assetName:---}"  "${filename:---}" >> "$manifestProjPath"
	static::PackageAsset::updateVInstalledHostmanifest
}


# usage: static::PackageAsset::updateProjectManifest
# This updates a project's local manifest by invoking static::PackageAsset::findAllProjectAssets to scan the project folder for
# assets of any known assetType. It writes the new list of assets to a sorted temp file and then only if its different than the
# .bglocal/manifest file, it overwrites it.
function static::PackageAsset::updateProjectManifest()
{
	local verbosity=${verbosity}
	while [ $# -gt 0 ]; do case $1 in
		-v|--verbose) ((verbosity++)) ;;
		-q|--quiet) ((verbosity--)) ;;
		*)  bgOptionsEndLoop "$@" && break; set -- "${bgOptionsExpandedOpts[@]}"; esac; shift;
	done

	local tmpFile="$(mktemp)"
	static::PackageAsset::findAllProjectAssets | sort > "$tmpFile"
	if [ ! -e $manifestProjPath ] || ! diff -q "$tmpFile" "$manifestProjPath" >/dev/null; then
		[ ! -e "${manifestProjPath%/*}" ] && mkdir -p "${manifestProjPath%/*}"
		cat "$tmpFile" > $manifestProjPath
		[ ${verbosity:-0} -ge 1 ] && echo "$manifestProjPath was updated"
		rm "$tmpFile"
		return 0
	else
		[ ${verbosity:-0} -ge 1 ] && echo "$manifestProjPath is already up to date"
		rm "$tmpFile"
		return 1
	fi
}

# usage: static::PackageAsset::updateVInstalledHostmanifest
# this is called by dev time tools (aka "bg-debugCntr vinstall" and PackageProject::updateManifest) to create/update a virtual host
# manifest file. "bg-debugCntr vinstall" sets the path in $bgVinstalledManifest and this function creates/updates it by starting
# with the actual installed manifest and then replacing any vinstalled projects
function static::PackageAsset::updateVInstalledHostmanifest() {
	if [ "$bgVinstalledManifest" ]; then
		local -a dirtyDeps
		local IFS=:; local vinstalledManifestFiles=($bgVinstalledPaths); IFS="$bgWS"
		vinstalledManifestFiles=("${vinstalledManifestFiles[@]/%/\/$manifestProjPath}")
		if fsGetNewerDeps --retArray=dirtyDeps "$bgVinstalledManifest" "$manifestInstalledPath" "${vinstalledManifestFiles[@]}"; then
			fsTouch "$bgVinstalledManifest" || assertError
			# the following awk script is passed the installed hostmanifest first and then the manifest of each vinstalled project.
			# The installed manifest is read directly into arrays collating by packagename. Then for each vinstalled project, its
			# array is reset if present from the installed manifest data and then added from the vinstalled project manaifest. The
			# net result is that any installed packages that are not vinstalled, will remain in the new manifest plus entries from
			# each vinstalled package.
			awk -v manifestProjPath="$manifestProjPath" '
				@include "bg_core.awk"
				BEGIN {arrayCreate(linesByPkg)}
				BEGINFILE {
					filePosition++
					if (filePosition>1) {
						basePath=gensub("/"manifestProjPath"$","","g",FILENAME)
					}

				}
				filePosition>1 && FNR==1 {
					# this will reset this pkgs array from the installed hostmanifest or create a new one if pkg was not in hostmanifest
					arrayCreate2(linesByPkg, $1)
				}
				{
					if (! ($1 in linesByPkg))
						arrayCreate2(linesByPkg, $1)
					sub($4"$",basePath"/"$4, $0)
					arrayPush(linesByPkg[$1], $0)
				}
				END {
					for (pkg in linesByPkg)
						for (i in linesByPkg[pkg])
							print linesByPkg[pkg][i];
				}
			' $(fsExpandFiles -f "$manifestInstalledPath") "${vinstalledManifestFiles[@]}" | sort > "$bgVinstalledManifest"
		fi
	fi
}

# usage: static::PackageAsset::listKnownAssetTypes
# print a list of known asset types to stdout
# This function gets the list of known types from three sources.
#    1) list of installed PackageAsset plugin instances in the current hostmanifest (i.e. installed assets)
#    2) any functions that fit the bgAssetInstall_<assetType>... naming convention (this picks up builtin assetTypes that dont have PackageAsset plugins)
#    3) any installed template with the naming newAsset.<assetType>[.subtype..]
function static::PackageAsset::listKnownAssetTypes()
{
	printf "  "

	$Plugin::loadAllOfType PackageAsset

	local assetTypeFn; for assetTypeFn in $( { compgen -A command bg-dev-install_; compgen -A function bgAssetInstall_; } | sort -u); do
		local assetType="${assetTypeFn#bg-dev-install_}"
		assetType="${assetType#bgAssetInstall_}"
		assetType="${assetType%__*}"
		assetType="${assetType//_/.}"
		printf "%s " "$assetType"
	done
	import bg_template.sh  ;$L1;$L2
	templateList "newAsset[.]" | sed 's/^newAsset[.]\([^+]*\).*$/\1/g'
	printf "\n"
}


# usage: static::PackageAsset::listProjectAssets
# do an awkData_query on the local project manifest file. This is similar to 'bg-awkData manifest'
function static::PackageAsset::listProjectAssets()
{
	local verbosity=${verbosity}
	while [ $# -gt 0 ]; do case $1 in
		-v|--verbose) ((verbosity++)) ;;
		-q|--quiet) ((verbosity--)) ;;
		*)  bgOptionsEndLoop "$@" && break; set -- "${bgOptionsExpandedOpts[@]}"; esac; shift;
	done

	assertNotEmpty manifestProjPath

	[ ! -e $manifestProjPath ] && static::PackageAsset::updateProjectManifest

	import bg_awkDataQueries.sh  ;$L1;$L2

	awkData_query --awkDataID="manifest|${manifestProjPath}-|" "$@"
}

# usage: static::PackageAsset::installAssets [-v] [-q] [--triggers=<trigObj>] <hostType> <destDir>
# Installs the assets from the project into <destDir> using the standard defined by <hostType>.
#
# Helper Commands or Functions:
# This function iterates the asset types in the project's manifest file and for each found, it looks for a helper command or function
# that matches the asset type name and install type (deb|rpm or generic) and executes that helper with the list of files or folders
# of that asset type present in the project. Each file or folder is relattive to the project's root folder. The helper is responsible
# to install the asset and also to append to the UNINSTSCRIPT a command that will undo the installation of each asset.
#
# Scraps from absorbing other libraries:
# TODO: merge the content in this section into other places, eliminating duplication
# The install behavior is responsible for installing an asset of that type into a host filesystem. Typically, the asset is contained
# in a single file and the install behavior copies it to the correct folder in the host filesystem. The install behavior can be
# subclased for each target system type (i.e. debian vs redhat) to comply with differing policies. The install behavior is invoked
# to prepare the staging filesystem for a package build and also if a project folder is directly installed onto a host (without building
# a package)
#
# This library provides the ability to install assets contained in a bg-dev style project.
# This library provides the static::PackageAsset::installAssets and static::PackageAsset::uninstallAssets functions used by the bg-dev tool.
# static::PackageAsset::installAssets iterates a bg-dev style project's manifest file and for each asset, invokes the install behavior defined by that
# assetType.  Some core assetTypes have builtin install functions but in general, each assetType has a PackageAsset plugin instance
# that must be installed on the dev-time host.
#
# As static::PackageAsset::installAssets runs, it builds a host manifest file and an unistall script.
#
# Typically the "bg-dev buildPkg" command calls static::PackageAsset::installAssets to create the staging folder that will go into the package.
# "bg-dev install" also calls static::PackageAsset::installAssets to install directly into the developer's host, but that is not in the typical workflow.
#
# Not all OS use the same policy for where assets of a given type should be placed so the install behavior of a PackageAsset plugin
# can be subclassed to treat each supported OS differently. Typically, the default install follows the debian standard and is invoked
# when a deb package is built and a separate .rpm behavior is needed to correctly build an rom package to install on redhat derivitives.
#
# Options:
#    --triggers=<trigObj> : <trigObj> is a bash object that implements methods for preinst,postinst,prerm,postrm events
#    -q : less output
#    -v : more output
# Params:
#    <hostType> : deb|rpm|detect : the type of the host system installing to. Assets are installed to the appropriate folders for
#                 the <hostType>. If the value is "detect" then the local host will be queried to determine the type of the host.
#    <destDir>  : the root folder of the system to install the project into. An empty value indicates that it will be installed
#                 into the local host's file system. When building a package for distribution, this should point to the staging
#                 folder for the package.
# See Also:
#    man(5) bgInstallHelpCmdProtocol
function static::PackageAsset::installAssets()
{
	local verbosity=${verbosity} noUpdateFlag
	while [ $# -gt 0 ]; do case $1 in
		-v|--verbose) ((verbosity++)) ;;
		-q|--quiet) ((verbosity--)) ;;
		--no-update) noUpdateFlag=1 ;;
		*)  bgOptionsEndLoop "$@" && break; set -- "${bgOptionsExpandedOpts[@]}"; esac; shift;
	done
	local -x INSTALLTYPE="$1"
	local -x DESTDIR="$2"

	if [ "$INSTALLTYPE" == "detect" ]; then
		INSTALLTYPE=""
		which apt &>/dev/null && INSTALLTYPE="deb"
		[ ! "$INSTALLTYPE" ] && which rpm &>/dev/null && INSTALLTYPE="rpm"
		[ ! "$INSTALLTYPE" ] && INSTALLTYPE="deb"
	fi
	[ "$DESTDIR" == "/" ] && DESTDIR=""

	if [ ! "$DESTDIR" ]; then
		# TODO: detect if the project is already installed and change "install" to "upgrade"
		[ -f pkgControl/preinst ] && { sudo ./pkgControl/preinst "install" || assertError; }
	fi

	[ "$DESTDIR" ] && [ ! -e "$DESTDIR/" ] && mkdir -p "$DESTDIR"
	local PRECMD; [ ! -w "$DESTDIR" ] && PRECMD="bgsudo "

	local UNINSTSCRIPT="${DESTDIR}/var/lib/bg-core/$pkgName/uninstall.sh"
	local HOSTMANIFEST="${DESTDIR}/var/lib/bg-core/$pkgName/hostmanifest"

	[ ${verbosity:-0} -ge 1 ] && printf "installing to %s\n" "${DESTDIR:-host filesystem}"

	export DESTDIR INSTALLTYPE PRECMD UNINSTSCRIPT pkgName manifestProjPath
	#export -f manifestReadOneType --file="$manifestProjPath" bgOptionsEndLoop varSet printfVars varIsA

	### if there is a previous installation, remove it
	if [ -f "$UNINSTSCRIPT" ]; then
		static::PackageAsset::uninstallAssets "$INSTALLTYPE" "$DESTDIR"
	fi

	### Start the HOSTMANIFEST file
	# fsTouch can not use $PRECMD b/c its a function (sudo only does files) but fsSudo will prompt sudo as needed
	fsTouch -p "$HOSTMANIFEST"
	$PRECMD truncate -s0 "$HOSTMANIFEST"

	### Start the $UNINSTSCRIPT script
	$PRECMD mkdir -p "${DESTDIR}/var/lib/bg-core/$pkgName"
	$PRECMD bash -c 'cat >"'"${UNINSTSCRIPT}"'"  <<-EOS
		#!/usr/bin/env bash
		#(its better to create a bespoke assertError) # [ -f /usr/lib/bg_core.sh ] && source /usr/lib/bg_core.sh
		[ "\$(type -t assertError)" != "function" ] && function assertError() {
		   printf "uninstall script failed: \n\tlocation:\$0(\${BASH_LINENO[0]})\n\tline: \$(gawk 'NR=='"\${BASH_LINENO[0]}"'' \$0)\n"
		   exit 2
		}
		function rmFile() {
		   local recurseFlag; [ "\$1" == "-r" ] && { recurseFlag="-r"; shift; }
		   local dirFlag;     [ -d "\$1" ] && dirFlag="-r"
		   [ "\$dirFlag" ] && [[ "\$1" =~ ^(/[^/]*)$ ]] && { printf "uninstall script warning: refused to remove top level folder '%s'\n" "\$1" ; return; }
		   [ -e "\$1" ]        && { \$preUninstCmd rm \$dirFlag -f "\$1" || return; }
		   [ "\$recurseFlag" ] && { \$preUninstCmd rmdir --ignore-fail-on-non-empty -p  "\${1%/*}" &>/dev/null; true; }
		   true
		}
		preUninstCmd=""; [ ! -w "\$0" ] && preUninstCmd="sudo "; true
		EOS' || assertError "error writing the initial uninstall script file contents"
	$PRECMD chmod a+x "${UNINSTSCRIPT}" || assertError

	### Update the asset manifest
	[ ! "$noUpdateFlag" ] && static::PackageAsset::updateProjectManifest

	# load any PackageAsset plugins avaialble so that their install functions will be found and executed
	Try:
		$Plugin::loadAllOfType PackageAsset
	Catch: { : }

	# iterate the assetTypes present in the manifest
	local -A types; manifestReadTypes --file="$manifestProjPath" types
	local type; for type in "${!types[@]}"; do
		assertNotEmpty type
		[ ${verbosity:-0} -ge 1 ] && printf "      %4s %s\n" "${types[$type]}" "$type"
		local files=(); manifestReadOneType --names --file="$manifestProjPath" files "$type"

		local helperFnName
		static::PackageAsset::assetGetFirstHelperCmd -R helperFnName  "bg-dev-install" "bgAssetInstall" "$type"
		if [ "$helperFnName" ]; then
			$helperFnName "$type" "${files[@]}"
		else
			assertError -v "helper Cmd Names in order of preference:${helperCmdCandidatesNames// /$'\n'}" -v assetType:type -v pkgName "
				No install helper command found for asset type '${type}'. You might need to install a plugin
				to handle this type of asset. This asset is listed in the project's .bglocal/manifest"
		fi
	done

	static::PackageAsset::_installFilesToDst --flat manifest "/var/lib/bg-core/$pkgName" "manifest" "$manifestProjPath"

	### Finish the $UNINSTSCRIPT script
	$PRECMD bash -c 'cat >>"'"${UNINSTSCRIPT}"'"  <<-EOS
		[ "$DESTDIR" ] && [ -d "$DESTDIR/DEBIAN" ] && { rm -f "$DESTDIR/DEBIAN/"*; rmdir  "$DESTDIR/DEBIAN/"; }
		rmFile -r '${HOSTMANIFEST}'
		rmFile -r '${UNINSTSCRIPT}'
		true
		EOS' || assertError "error writing the final uninstall script file contents"
	$PRECMD chmod a+x "${UNINSTSCRIPT}"

	# if installing to the local host, run the posinstall script
	if [ ! "$DESTDIR" ]; then
		# TODO: detect if the project is already installed and change "install" to "upgrade"
		[ -f pkgControl/postinst ] && { sudo ./pkgControl/postinst "install"; }
	fi
}


# usage: bg-dev static::PackageAsset::uninstallAssets [-v|-q] [--pkgType=deb|rpm]
function static::PackageAsset::uninstallAssets()
{
	local verbosity=${verbosity}
	while [ $# -gt 0 ]; do case $1 in
		-v|--verbose) ((verbosity++)) ;;
		-q|--quiet) ((verbosity--)) ;;
		*)  bgOptionsEndLoop "$@" && break; set -- "${bgOptionsExpandedOpts[@]}"; esac; shift;
	done
	local -x INSTALLTYPE="$1"
	local -x DESTDIR="$2"

	if [ "$INSTALLTYPE" == "detect" ]; then
		INSTALLTYPE=""
		which apt &>/dev/null && INSTALLTYPE="deb"
		[ ! "$INSTALLTYPE" ] && which rpm &>/dev/null && INSTALLTYPE="rpm"
		[ ! "$INSTALLTYPE" ] && INSTALLTYPE="deb"
	fi
	[ "$DESTDIR" == "/" ] && DESTDIR=""

	# if the DESTDIR does not exist, the unistall is done by definition
	[ ! -e "$DESTDIR/" ] && return 0

	# see if we need sudo to modify DESTDIR
	local PRECMD; [ ! -w "$DESTDIR" ] && PRECMD="bgsudo "

	# if uninstalling from the local host, run the prerm script
	if [ ! "$DESTDIR" ]; then
		# TODO: detect if the project is being upgraded and change "remove" to "upgrade"
		[ -f pkgControl/prerm ] && { sudo ./pkgControl/prerm "remove"; }
	fi

	local UNINSTSCRIPT="${DESTDIR}/var/lib/bg-core/$pkgName/uninstall.sh"

	# if there is a $UNINSTSCRIPT installed, call it to remove the last version before we install the current version.
	# this makes it clean when we remove or rename files in this library so that we dont leave obsolete files in the system
	[ -x "${UNINSTSCRIPT}" ] && { "${UNINSTSCRIPT}" || assertError -v UNINSTSCRIPT "
		The uninstall script from the previous installation ended with an error.
		You can edit that script to get around the error and try again. If you
		remove or rename that script this step will be skipped by the installer.
		There may or may not be steps in the uninstall script that need to complete
		before this package will install correctly so if you remove it, make a copy"; }

	# if uninstalling from the local host, run the postrm script
	if [ ! "$DESTDIR" ]; then
		# TODO: detect if the project is being upgraded and change "remove" to "upgrade"
		[ -f pkgControl/postrm ] && { sudo ./pkgControl/postrm "remove"; }
	fi
}



#################################################################################################################################
### Static Members - Miscelanoeous

# usage: static::PackageAsset::assetGetFirstHelperCmd [-R|--retVar=<retVar>] <baseCmdName> <baseFunctionName> <assetType>
# This is a helper function that applies the algorithm to find the first of a set of functions that can handle an operation for
# <assetType>
# TODO: consider scrapping this mechanism now that we have real object oriented plugins
function static::PackageAsset::assetGetFirstHelperCmd()
{
	local retVar
	while [ $# -gt 0 ]; do case $1 in
		-R*|--retVar*)  bgOptionGetOpt val: retVar "$@" && shift ;;
		*)  bgOptionsEndLoop "$@" && break; set -- "${bgOptionsExpandedOpts[@]}"; esac; shift;
	done
	local baseCmdName="$1"
	local baseFunctionName="$2"
	local assetType="$3"

	local typeSuffix="${assetType//./_}"
	local helperCmdCandidatesNames=""
	while [ "$typeSuffix" ]; do
		helperCmdCandidatesNames+=" ${baseCmdName}_${typeSuffix}__${INSTALLTYPE} ${baseFunctionName}_${typeSuffix}__${INSTALLTYPE} ${baseCmdName}_${typeSuffix} ${baseFunctionName}_${typeSuffix}"
		[[ ! "$typeSuffix" =~ _ ]] && typeSuffix=""
		typeSuffix="${typeSuffix%_*}"
	done

	local helperFnName found=''
	for helperFnName in $helperCmdCandidatesNames; do
		if which $helperFnName &>/dev/null || [ "$(type -t $helperFnName)" == "function" ]; then
			found="$helperFnName"
			break;
		fi
	done
	returnValue "$found" $retVar
	[ "$found" ]
}




#################################################################################################################################
### Static Members for addNewAsset Behavior

# usage: static::PackageAsset::createNewAssetFromTemplate <assetType> <assetName> <destFile>
# This is a generic static helper function typcally used in the ::addNewAsset() method of derived PackageAsset instances. This allows the
# PackageAsset class to 1) control the naming and subfolder convention for assets of this type, 2) choose a template to use. This
# is all that many AssetTypes will need.
# The addNewAsset behavoir adds a new asset of that type to a project. It is invoked by the "bg-dev assets addNewAsset <assetType> -- <assetName>"
# command. Typically it will expand a template to create a new file following the placement and naming convention used by that asset type.
function static::PackageAsset::createNewAssetFromTemplate()
{
	local permOpt
	while [ $# -gt 0 ]; do case $1 in
		--perm*)  bgOptionGetOpt opt: permOpt "$@" && shift ;;
		*)  bgOptionsEndLoop "$@" && break; set -- "${bgOptionsExpandedOpts[@]}"; esac; shift;
	done
	local assetType="${1#newAsset.}"; shift; assertNotEmpty assetType
	local newAssetName="$1"; shift; assertNotEmpty newAssetName
	local destFile="$1";     shift; assertNotEmpty destFile

	[ -e "$destFile" ] && assertError "An asset already exists at '$destFile'"

	import bg_template.sh  ;$L1;$L2
	local templateFile; templateFind -R templateFile "newAsset.$assetType"
	[ ! "$templateFile" ] && assertError -v assetType -v assetName -v destFile -v templateName:-l"newAsset.$assetType" -v templateFile "The template to create a new '$assetType' asset was not found on this host."

	templateExpand "$templateFile" "$destFile" || assertError
	[ "$permOpt" ] && fsTouch "${permOpt[@]}" "$destFile"

	# by adding the asset here, it saves running the complete findAllProjectAssets scan but the next time findAllProjectAssets runs
	# it will be equivalant
	static::PackageAsset::addAssetToManifest "${assetType:---}"  "${newAssetName:---}"  "${destFile:---}"

	echo "A new asset has been added at '$destFile' with default values. Edit that file to customize it."
}




#################################################################################################################################
### Static Members for find/scan Behavior that identifies assets in a project


# usage: static::PackageAsset::findAllProjectAssets
# This scans the project folder and writes to stdout a line for each found asset.
# It iterates all the assetTypes known on this host and for each one, it finds and invokes the assetType's find behavior.
# There are a number of builtin assetTypes for which this function knows how to find assets. Also assetTypes can be added by
# installing a package that contains a PackageAsset plugin instance.
#
# The output of this command can be redirected to create a project's ./.bglocal/manifest file.
#
# Line Format:
# Each line has the format...
#    <pkgName> <assetType> <assetName> <fileOrFolder>
# Data Flow:
#   Step 1) this function makes/updates each project's ./.bglocal/manifest
#   Step 2) use the project manifest files to creat/update the hostmanifest
#   Step 2a) when a package is built (deb or rpm) the install behavior uses ./.bglocal/manifest to iterate the assets and copies the
#            asset files to the staging folder while creating the hostmanifest file for the package. The difference is that the paths
#            in the project manifest are relative to the the project root folder but are absolute paths in the hostmanifest.
#             project manifest files are simply concatonated to make the host manifest.
#   Step 2b) when vinstalled, the project's host manifest is created with full absolute paths to the assets where they reside in
#           project folders and then concatonated into a vinstalled hostmanifest file (typically in the sandbox's /bglocal/)
function static::PackageAsset::findAllProjectAssets()
{
	local -A fileList=();

	# TODO: when vinstall'ing bg-dev/bg-core on a fresh host for the first time, the host manifest will be empty. Add code here to
	#       detect that and load manually the PackageAsset.PluginType and any *.PackageAsset plugins from bg-dev.


	# load any PackageAsset plugins available so that their find functions will be found and executed
	# we load the ones that we know about from bg-dev manually with import because the first time bg-dev is vinstalled on a fresh
	# host, the hostmanifest file will be empty. This is a narrow bootstrap issue -- when bg-dev and bg-core are actually installed its not an issue.
	import awkDataSchema.PackageAsset  ;$L1;$L2
	import template.PackageAsset  ;$L1;$L2
	$Plugin::loadAllOfType PackageAsset

	# export things for helper plugins to use
	export pkgName

	# now invoke any plugins available
	local findAssetCmd; for findAssetCmd in $({ compgen -A command bg-dev-findAsset; compgen -A function bgAssetFind; } | sort -u); do
		$findAssetCmd #>> $_bgtraceFile
	done
}

# usage: static::PackageAsset::_findAssetsOfType [--rmSuffix=<suffix>] [--template=<nameTemplate>] <assetType> <findTerms...>
# This is a helper function that can be used to implement the find behavior of an assetType.
# If the options and bgfind filter terms are not sufficient to implemnt the search for a particular asstType you can copy and modify
# the function for that assetType.
# Options:
#    --rmSuffix=<suffix>       : when making the assetName from the found filename, remove this suffix from the filename
#    --template=<nameTemplate> : use this template to make the assetName. The variable %name% can be used in the template and will
#                                have the value that assetName would have had if this option was not specified
# Params:
#    <assetType>     : The type of asset being found by this invocation
#    <findTerms...>  : the terms passed through to fsExpandFiles (similar to gnu 'find' utility) that match only asset files of
#                      <assetType>
function static::PackageAsset::_findAssetsOfType()
{
	local rmSuffix nameTemplate
	while [ $# -gt 0 ]; do case $1 in
		--rmSuffix*) bgOptionGetOpt val: rmSuffix "$@" && shift ;;
		--template*) bgOptionGetOpt val: nameTemplate "$@" && shift ;;
		*)  bgOptionsEndLoop "$@" && break; set -- "${bgOptionsExpandedOpts[@]}"; esac; shift;
	done
	local assetType="$1"; shift
	local -A fileList=()
	local templateExcludeExpr=(); [ "$assetType" != "template" ] && templateExcludeExpr=( --exclude=/templates )
	fsExpandFiles -S fileList --gitignore "${templateExcludeExpr[@]}" "$@"
	local filename; for filename in "${!fileList[@]}"; do
		local assetName="${filename%/}"
		assetName="${assetName##*/}"
		if [[ ! "$filename" =~ /$ ]] && [[ "$assetName" =~ $rmSuffix$ ]]; then
			assetName="${assetName%${BASH_REMATCH[0]}}"
		fi
		[ "$nameTemplate" ] && assetName="${nameTemplate//%name%/$assetName}"
		printf "%-20s %-20s %-20s %s\n" "${pkgName:---}" "${assetType:---}"  "${assetName:---}"  "${filename:---}"
	done
}



#################################################################################################################################
### Static Members for install Behavior








# usage: static::PackageAsset::_installFilesToDst <pkgPath> <dstPath>   <type> [<fileOrFolder1>...<fileOrFolderN>]
# This is a helper function typically used by asset install helper functions to copy their asset files to the DESTDIR.
# It can support several common patterns based on what options are specified.
#
# static::PackageAsset::installAssets() will bundle assets in a project into sets with the same assetType and call the install helper for that
# assetType passing in the specific assetType and a list of files or folders of assets of that type. If a helper function uses this
# function, it adds the first two arguments of this function and then passes through the assetType and filenames. This function also
# accepts several options that affect the way it installs the filenames.
#
# The <pkgPath> <dstPath> parameters allow this function to turn the relative project path of each asset into the absolute path
# in the destination filesystem. <pkgPath> is required because sometimes assets are put in a folder just to better organize the
# assets in the project and sometimes they are in a folder hierarchy that should be reproduced in the target filesystem. The
# general algorithm is to remove the <pkgPath> from the front and prepend <dstPath> but that can be changed with the --flat option.
# When --flat is specified, the entire projet path is ignored and all of these asset files are placed directly in <dstPath>.
#
# The --zipSpec option identifies destination files that should be compressed with gzip (such as copyright and changelog files)
#
# Install Helper Functions:
# To support a new assetType, a new function needs to be created specific to that assetType and many times all that function needs
# to do is call this function with the appropriate arguments.
# There are two mechanisms for to create an assetType install function. The typical way is to create a new PackageAsset plugin which
# will contain a function for installing as well as one for scanning and another to add a new asset of that type to a project.
# There is also an older convention that is still used by the builtin assets that is to create a function by the name
# bgAssetInstall_<assetType>.  Since that function needs to be loaded, that mechanism works well for builtin assetTypes but for
# assetTypes provided by thrid party packages, the PackageAsset method is required.
# The complete naming convention is documented in `man(5) bgAssetInstallPluginProtocol`
# An assetType install function does not need to use this function. `man(5) bgAssetInstallPluginProtocol`  descibes what the function
# has to do to install an asset correctly.
# Params:
#    <pkgPath> : the path prefix of the asset in the project folder. This part of the asset path will not be reproduced in the <dstPath>
#    <dstPath> : the destination folder where assets of this type are installed. The asset path structure will be reproduced here
#    <type>    : the asset type. (e.g. cmd, lib.bash, awkLib, manpage, etc...) of the list of files that follow
#                The bgInstaller may call the same helper multiple times with a different value of <type> because it could use the
#                same helper for multiple qualified asset types. e.g. if a handler handles any "lib" type it could be called with
#                "lib.bash" and "lib.python".
#    <fileOrFolderN>   : filenames of assets of this type to install. Note that if no <fileOrFolderN> are passed to this function, the manifest file
#                will be read to get the list of asset files to process.
# Options:
#    -z|--zipSpec=<regex> : Any <fileOrFolderN> that matches this expression will be compressed into a .gz file instead of copied as is.
#                           '^' matches all files. The motivation was the doc folder where the changelog file needs to be
#                           compressed but other doc files do not.
#    -f|--flat : causes all files to be placed in the root of <dstPath> regardless of the relative path of the file in the project
#    --renameFile : causes the destination filename to take the assetName instead of the original asset's filename
function static::PackageAsset::_installFilesToDst() {
	local zipSpec="^$" # default is to match no files
	local flatFlag recurseRmdir="-r" renameFileFlag
	while [ $# -gt 0 ]; do case $1 in
		-z*|--zipSpec*) bgOptionGetOpt val: zipSpec "$@" && shift ;;
		-f|--flat)  flatFlag="-f"; recurseRmdir="" ;;
		--renameFile) renameFileFlag="--renameFile" ;;
		*)  bgOptionsEndLoop "$@" && break; set -- "${bgOptionsExpandedOpts[@]}"; esac; shift;
	done

	local pkgPath="$1"; shift
	local dstPath="${DESTDIR}$1"; shift

	local assetType="$1"; shift

	local files=(); [ $# -eq 0 ] && { manifestReadOneType --file="$manifestProjPath" files "$assetType" || assertError; }
	for file in "$@" "${files[@]}"; do
		# TODO: 2021-02-22: the original protocol only passed <assetFile> and not <assetName>|<assetFile> in each token so this
		#       code checks for the presense of a | to determine which is being sent. after the transition, we can remove that
		local assetName=""
		if [[ "$file" =~ [|] ]]; then
			assetName="${file%%|*}"
			file="${file#*|}"
		else
			# this is the old way that gleans the assetName from the filename, but its much better to use the name from the manifest
			assetName="${file%/}"
			assetName="${assetName##*/}"
			[[ ! "$file" =~ /$ ]] && assetName="${assetName%%.*}"
		fi

		# some assets were ending up with the useless './' prefix and that messes up the recursive folder removal in uninstallscript
		# its probably some ways that static::PackageAsset::_findAssetsOfType() is called
		file="${file#./}"

		# sanity check...
		{ [ ! "$file" ] || [ ! -e "$file" ]; } &&  assertError -v assetType -v file "file does not exist in the project"

		### determine the full dstFile path. This is the main algorithm of this function based on <pkgPath>,<dstPath>, and <flatFlag>
		# start with the project filename
		local dstFile="$file"
		# replace the name part with the assetName if called for
		if [ "$renameFileFlag" ]; then
			if [[ "$dstFile" =~ [/] ]]; then
				dstFile="${dstFile%/*}/${assetName}"
			else
				dstFile="${assetName}"
			fi
		fi
		# now add the dstPath prefix.
		if [ "$flatFlag" ]; then
			dstFile="${dstPath}/${dstFile##*/}"
		else
			dstFile="${dstPath}/${dstFile#$pkgPath}"
		fi

		# make sure that the asset's parent folder exists in the destination
		local dstFolder="${dstFile%/*}"
		[ ! -e "$dstFolder" ] && { $PRECMD mkdir -p "$dstFolder" || assertError; }

		# copy to the destination, zipping if needed
		if [[ "$file" =~ $zipSpec ]] && [[ ! "$file" =~ [.]gz$ ]]; then
			dstFile="${dstFile}.gz"
			gzip -n -f -9  < "$file" | $PRECMD tee "$dstFile" >/dev/null || assertError
		else
			$PRECMD cp -r "$file" "$dstFile" || assertError
		fi

		# write this asset to the HOSTMANIFEST
		printf "%-20s %-20s %-20s %s\n" "$pkgName" "$assetType" "$assetName" "${dstFile#${DESTDIR}}" | $PRECMD tee -a  $HOSTMANIFEST >/dev/null

		# write the uninstall cmd to the UNINSTSCRIPT
		echo "rmFile $recurseRmdir '$dstFile' || assertError" | $PRECMD tee -a  "${UNINSTSCRIPT}" >/dev/null
	done
}


# man(5) bgAssetInstallPluginProtocol
# bgAssetInstall uses an polymorphic system to install assets correctly given their assetType.
# bgAssetInstall is used by the bg-dev command when it needs to install assets into the target OS filesystem which could be a staging
# folder in preparation of building a deb or rpm package, or it could be a host's real filesystem when a project folder is directly
# installed.
#
# bgAssetInstall will iterate a project's assets listed in its manifest file and for each a set of assets of the same fully qualified
# assetType it will invoke a function that is specific to the assetType.
#
# Two mechanisms are avaiable to create the install function for a new assetType.
#
# PackageAsset Method:
# The newer and generally prefered method is to create a PackageAsset plugin instance in the package that provides the new assetType
# functionality. Use "bg-dev assets addNewAsset plugin.PackageAsset -- <newAssetTypeName>" to create a new assetType in a package
# project.  The plugins/<newAssetTypeName>.PackageAsset file that it creates has fucntions defined for scan, install, and addNewAsset
# with typical generic implementations that can then be modified to suite the behavior of the specific assetType.
#
# The plugin functions actually use the second, lower level method so we can think of the plugins as a convenient wrapper over that
# that method. The plugin's method functions must use the naming convention described in the next section.
#
# Function Naming Convention Method:
# The lower level method is used directly by the builtin assetTypes provided by bg-dev.  It is based on naming a bash function (or
# an external command) to identify the function as the install behavior for an specific assetType.
#
# An assetType built into bg-dev can define a function in this library with the correct name for the assetType. Because this librabry
# must be loaded to run static::PackageAsset::installAssets, the helper functions defined in it will be automatically available.
#
# This naming convention also works for external commands as well as for functions but that is typically not used. With the advent
# of the PackageAsset plugin, using external command helper functions is not needed and if an external command helpwe is required,
# it can be invoked from the plugin's method (aka function).
#
# This naming convention also allows the install behavior for an assetType to be subclassed to handle the installation to different
# OS correctly. Two types of OS are initially supported -- 'deb' for installation into debian style OS and 'rpm' for installation
# into redhat style OS.
#
# The function or command used to install an assetType is the first one that exists in the following list.
#   * bg-dev-install_<assetTypeStr>__<installType>       # external command, specific to <installType>
#   * bgAssetInstall_<assetTypeStr>__<installType>       # sourced function, specific to <installType>
#   * bg-dev-install_<assetTypeStr>                      # external command that works for any <installType>
#   * bgAssetInstall_<assetTypeStr>                      # sourced function that works for any <installType>
#   * Note that <assetTypeStr> is the asset type with '.' replaced with '_'.
#   * Note that there are two '_' between <assetTypeStr> and <installType> to distinguish <installType> from names with '_'
#   * if asset name contains a qualification (e.g. cmd.script.bash), if no function nor command is found, the last qualification
#     is removed and the above names checked again. This is repeated until a function or command is found or <assetTypeStr> is empty.
#
# Subclassing For OS and AssetType Qualifications:
# This naming scheme allows one generic helper to handle all assets of a base type installed to any OS but also if there are different
# install procedures for a specific subtype of that assetType or when that assetType is installed on a specific OS, a new function
# can be added to handle that case differently.
#
# For example...
#      bgAssetInstall_lib()              installs lib assetTypes into the /usr/lib/ folder.
#      bgAssetInstall_lib_script_awk()   installs lib.script.awk assetTypes into the /usr/share/awk/ folder.
#
# It is also possible to write the bgAssetInstall_lib() function to be aware that awk script libraries have to go to a different place.
# It can examine the actual fully qualified assetType name and also the INSTALLTYPE Environment variable and take appropriate action.
# The author of an assetType can decide which way to do it.
#
# Asset names can be qualified with periods. For example `lib` is a generic library asset that might be a bainary file or a script.
# 'lib.binary' is specifically a compiled library file and 'lib.script.bash' is specifically a bash script library.
#
#
# CAll Protocol - Params:
# An install helper function is invoked by static::PackageAsset::installAssets like this...
#      <helperCmd> <assetType> <fileOrFolder1>[..<fileOrFolderN>]
# where...
#    <assetType>     : the specific asset type that may include qualifications (like lib.bash) that the following files or folders
#                      belong to.
#    <fileOrFolderN> : a file object to install.
#
# CAll Protocol - Environment Available:
# The following environment variables are available when helper commands or functions are called...
#    * DESTDIR          : the top of the path where the project is being installed. Empty means its being installed in the root filesystem
#    * INSTALLTYPE      : deb|rpm. Determines the standard of the target filesystem. Others may be added in the future.
#    * PRECMD           : this is meant to prefix commands that modify the DESTDIR. If the user does not have permissions to modify
#                         DESTDIR, this will contain the sudo command that gives the user sufficient permissions. It will be empty
#                         if the useer does have sufficient permission. It assumes that permissions to modify the root of DESTDIR
#                         is sufficient to modify any path relative to DESTDIR
#    * UNINSTSCRIPT     : The path of the uninstall script that is being built up by the installation. For each action the helper
#                         does to modify DESTDIR, it should append a line to this script that undoes it. The script provides the
#                         `rmFile [-r] <target>` function that can be used to undo the action of copying a file. If -r is specified,
#                         if it removes the last file in a folder, that folder will also be removed.
#    * pkgName          : The name of the package being installed.
#    * manifestProjPath : The path of the package's manifest file relative to the prject root. The list of files or folders sent to
#                         the helper came from this file. On rare ocassions, the helper may want to query the manifest to see what
#                         other related assets are being installed.



#################################################################################################################################
### Builtin Assets


# FUNCMAN_AUTOOFF
### define the built-in helper functions for all the known asset types. Each of these are discovered by the builtin section of the
# static::PackageAsset::findAllProjectAssets function
# note that an install* function does not have to use static::PackageAsset::_installFilesToDst. It can do anything it wants to represent its assets in
# the destination file system. See man(1) bg-dev-install and the static::PackageAsset::_installFilesToDst function as a model to build a custom helper.
function bgAssetInstall_unitTest()   { : ; } # unittests are not installed
#                                                                       <pkgPath>      <dstPath>                   <pass thru type plus filepaths>
function bgAssetInstall_cmd()        { static::PackageAsset::_installFilesToDst --flat             ""             "/usr/bin"                  "$@" ; }
function bgAssetInstall_lib()        { static::PackageAsset::_installFilesToDst --flat             ""             "/usr/lib"                  "$@" ; }
function bgAssetInstall_etc()        { static::PackageAsset::_installFilesToDst                    "etc/"         "/etc"                      "$@" ; }
function bgAssetInstall_opt()        { static::PackageAsset::_installFilesToDst                    "opt/"         "/opt"                      "$@" ; }
function bgAssetInstall_data()       { static::PackageAsset::_installFilesToDst                    "data/"        "/usr/share/$pkgName"       "$@" ; }
function bgAssetInstall_template()   { static::PackageAsset::_installFilesToDst                    "templates/"   "/usr/share/$pkgName"       "$@" ; }
function bgAssetInstall_template_folder() { static::PackageAsset::_installFilesToDst --renameFile  "templates/"   "/usr/share/$pkgName"       "$@" ; }
function bgAssetInstall_doc()        { static::PackageAsset::_installFilesToDst -z "doc/changelog" "doc/"         "/usr/share/doc/$pkgName"   "$@" ; }
function bgAssetInstall_manpage()    { static::PackageAsset::_installFilesToDst -z "^"             ".bglocal/funcman" "/usr/share/man"        "$@" ; }
function bgAssetInstall_cron()       { static::PackageAsset::_installFilesToDst                    "cron.d/"      "/etc/cron.d"               "$@" ; }
function bgAssetInstall_sysVInit()   { static::PackageAsset::_installFilesToDst                    "init.d/"      "/etc/init.d"               "$@" ; }
function bgAssetInstall_sysDInit()   { static::PackageAsset::_installFilesToDst                    "systemd/"     "/etc/systemd/system"       "$@" ; }
function bgAssetInstall_syslog()     { static::PackageAsset::_installFilesToDst                    "rsyslog.d/"   "/etc/rsyslog.d"            "$@" ; }
function bgAssetInstall_globalBashCompletion() { static::PackageAsset::_installFilesToDst --flat   ""             "/usr/share/$pkgName/bash_completion.d" "$@" ; }
function bgAssetInstall_lib_script_awk()       { static::PackageAsset::_installFilesToDst --flat   ""             "/usr/share/awk"            "$@" ; }
# FUNCMAN_AUTOON

# usage: bgAssetInstall_plugin
# TODO: this function ignores the filenames of the assets passed to it and iterates the manifest file so it can get the correct assetName
#       which is not easily derived from the filename. After the change to pass <assetName>|<assetFile>, we can use the generic static::PackageAsset::_installFilesToDst
#       like most other builtin assets do
function bgAssetInstall_plugin() {
	local type="$1"; shift
	[ "$type" == "plugin" ] || assertError "logic error. bgAssetInstall_plugin called with the wrong asset type"

	local dstPath="${DESTDIR}/usr/lib"
	[ ! -e "$dstPath" ] && { $PRECMD mkdir -p "$dstPath" || assertError; }

	local assetPkg assetType assetName assetFile
	while read -r assetPkg assetType assetName assetFile; do
		{ [ ! "$assetFile" ] || [ ! -f "$assetFile" ]; } &&  assertError -v type -v assetFile "This file listed in the project manifest does not exist in the project"
		local dstFile="${dstPath}/${assetFile##*/}"
		local dstFolder="${dstFile%/*}"
		$PRECMD cp "$assetFile" "$dstFile" || assertError

		# write this asset to the HOSTMANIFEST
		printf "%-20s %-20s %-20s %s\n" "$assetPkg" "$assetType" "$assetName" "${dstFile#${DESTDIR}}" | $PRECMD tee -a  $HOSTMANIFEST >/dev/null

		echo "rmFile '$dstFile' || assertError" | $PRECMD tee -a  "${UNINSTSCRIPT}" >/dev/null
	done < <(manifestGet --manifest="$manifestProjPath" "plugin" ".*")
}

# usage: bgAssetFind_plugin
# scan for any plugin instances in this project and print manifest lines to stdout
# This is logically part of the plugin.PackageAsset except plugins is one of the builtin assets so it does not have a plugin.PackageAsset
function bgAssetFind_plugin()
{
	# pre-populate the list with some known types so that assets of those types will be found even if something is wrong
	local -A pluginTypeSet=([PluginType]= [Config]= [Standards]= [Collect]= [BgGitFeature]= [RBACPermission]= [PackageAsset]= [FreshVMs]=)
	$Plugin::types -a -S pluginTypeSet

	local pluginType findTerm orTerm
	for pluginType in "${!pluginTypeSet[@]}"; do
		findTerm+=" $orTerm -name *.${pluginType} "
		orTerm=" -o "
	done

	# TODO: considering scanning all text files in the project for DeclarePlugin and DeclarePluginType. This would pickup unknown plugin types
	local -A fileList=(); fsExpandFiles -f -S fileList --gitignore --exclude=/templates --exclude=/pkgControl -R -- ./* -type f \( $findTerm \)
	local pluginType pluginID filename
	while read -r pluginType pluginID filename; do
		[[ "$filename" =~ templates/ ]] && continue
		printf "%-20s %-20s %-20s %s\n" "${pkgName:---}" "plugin"  "${pluginType}:${pluginID}"  "${filename}"
	done < <(gawk --include="bg_core.awk" '
		$1=="DeclarePlugin" {print $2 " " $3 " " FILENAME}
		$1=="DeclarePluginType" {print "PluginType " $2 " " FILENAME}
	' "${!fileList[@]}")
}



# usage: bgAssetFind_buitinAssets
# This function consolidates the bgAssetFind behavior for most of the builtin assets
# It scans the project folder tree and for each builtin asset it finds, writes a manifest line to stdout.
function bgAssetFind_buitinAssets()
{
	# TODO: all these builtin asset scanners could be combined into one bgfind invocation which would be more efficient. So far its
	#       very fast even making mutiple scans but if it gets noticably slower on big projects, we could make that change.
	#            (assetName=file-rmSuffix)   assetType                   (cmdline passed through to bgfind to filter for the asset files)

	# script libraries of various types are identified by their extension and can reside in any sub folder (but typically ./lib/)
	static::PackageAsset::_findAssetsOfType --rmSuffix="[.]sh"     "lib.script.bash"           -R  --exclude=/unitTests -- ./*  -type f  -name "*.sh"
	static::PackageAsset::_findAssetsOfType --rmSuffix="[.]awk"    "lib.script.awk"            -R  --exclude=/unitTests -- ./   -type f  -name "*.awk"
	static::PackageAsset::_findAssetsOfType --rmSuffix="[.]ut"     "unitTest"                  -R  -- unitTests/*               -type f  -perm /a+x -name "*.ut"
	static::PackageAsset::_findAssetsOfType --rmSuffix=""          "manpage"                   -R  -- man[1-9] .bglocal/funcman -type f  -path "*man*/*.[1-9]*"
	static::PackageAsset::_findAssetsOfType --rmSuffix=""          "etc"                       -R  -- etc/                      -type f
	static::PackageAsset::_findAssetsOfType --rmSuffix=""          "opt"                       -R  -- opt/                      -type f
	static::PackageAsset::_findAssetsOfType --rmSuffix=""          "data"                      -R  -- data/                     -type f
	static::PackageAsset::_findAssetsOfType --rmSuffix="[.]btpl"   "template"                  -R  --exclude="*.template/" -- templates/                -type f
	static::PackageAsset::_findAssetsOfType --rmSuffix="[.]template" "template.folder"         -R  -- templates/                -type d -name "*.template"
	static::PackageAsset::_findAssetsOfType --rmSuffix=""          "doc"                       -R  -- readme.md README.md doc/  -type f
	static::PackageAsset::_findAssetsOfType --rmSuffix=""          "cron"                      -R  -- cron.d/                   -type f
	static::PackageAsset::_findAssetsOfType --rmSuffix=""          "sysVInit"                  -R  -- init.d/                   -type f
	static::PackageAsset::_findAssetsOfType --rmSuffix=""          "sysDInit"                  -R  -- systemd/                  -type f
	static::PackageAsset::_findAssetsOfType --rmSuffix=""          "syslog"                    -R  -- rsyslog.d/                -type f
	static::PackageAsset::_findAssetsOfType --rmSuffix=""          "globalBashCompletion"      -R  -- ./*                       -type f  -name "*.globalBashCompletion"
}


# usage: bgAssetFind_cmd
# This is the asset find behavior for assetType=='cmd' (executable commands)
# commands are executables without an extension in the project root folder.
function bgAssetFind_cmd()
{
	local -A fileList=()
	fsExpandFiles -S fileList --gitignore --exclude=/templates --exclude=/pkgControl -- ./* -perm /a+x -type f '!' -name "*.*" '!' -name Makefile
	local filename; for filename in "${!fileList[@]}"; do
		local mimeType="$(file -ib "$filename")"
		if [[ "$mimeType" =~ charset=binary ]]; then
			assetType="cmd.binary"
		else
			case $(file "$filename") in
				*Bourne-Again*) assetType="cmd.script.bash" ;;
				*) assetType="cmd.script" ;;
			esac
		fi

		local assetName="${filename%/}"
		assetName="${assetName##*/}"
		[[ ! "$filename" =~ /$ ]] && assetName="${assetName%%.*}"

		printf "%-20s %-20s %-20s %s\n" "${pkgName:---}" "${assetType:---}"  "${assetName:---}"  "${filename:---}"
	done
}
