#!/bin/bash

# CRITICALTODO: see below
# SECURITY: consider how we can discourage use of bg-debugCntr on production servers -- provide an alternative that only controlls tracing -- put similar code here as in bg_core.sh to detect mode and hide/disable fetures based on that. Of course a user can do want they want with their environment but we can avoid facilitating a insecure practice
#           maybe this means that bg-debugCntr and Makefile both should only be in bg-scriptprojectdev -- maybe a stripped done bg-traceCntr should be in bg-lib
#           see also function bgListAllInstalledCodeFiles() -- whow it finds Makefile


declare -x bgVinstallInhibitPostProcessing

# This script implements a pattern where it can be installed into the user's bash session by sourcing
# it directly into the interactive bash shell. Once installed, a function by the same name will be
# defined so that when this command's name is ran in the interactive prompt or in a script, the
# sourced function version will be executed instead of the disk file.

# bgDebugCntrRunMode is maintained to let global code in this file know the context that its being ran
# its undefined at the end of the script so that when sourced functions run normally it will not be
# defined. [ ! "${bgDebugCntrRunMode+exits}" ] && echo "sourced function running"
# This is implemented as a function because bash 5.x no longer sets FUNCNAME[0] to 'main' or 'source'
# in the global scope
declare bgDebugCntrRunMode=""
function _getGlobalBashScope()
{
	case "PRE.${FUNCNAME[@]: -1}" in
		PRE.main|PRE.)    bgDebugCntrRunMode="extScript" ;;
		PRE.source)       bgDebugCntrRunMode="sourcing" ;;
		PRE.debugCntr)    bgDebugCntrRunMode="reloading" ;;
		PRE.bg-debugCntr) bgDebugCntrRunMode="reloading" ;;
		*)                bgDebugCntrRunMode="unknown:${FUNCNAME[@]: -1}"; echo "error: bg-debugCntr:_getGlobalBashScope() the reported top level bash FUNCNAME ($bgDebugCntrRunMode) is not recognized so we do not know the context that this script is running." >&2 ;;
	esac
}
_getGlobalBashScope


#################################################################################################################################
# Entry Point Functions
# These functions are meant to be invoked directly by the user. They typically exist as an external
# command script but when they are sourced, these functions override the invocation of those scripts.

# usage: bg-sp-addCommand ... (see man bg-sp-addCommand)
# this is a stub function for the external command bg-sp-addCommand so that it can source the bash
# completion script of the new command so that BC will start working right away.
function bg-sp-addCommand()
{
	# disable the DEBUG trap handler while we are in this function
	builtin trap - DEBUG

	local fullPath="$(which bg-sp-addCommand)"
	command "$fullPath" "$@"

	for i in "data/bashCompletion/"*; do
		[ -f "$i" ] && source "$i"
	done

	# if this feature is turned on, re-enable the DEBUG trap handler
	if [ "$bgBashCmdHookFeature" ]; then
		builtin trap 'cmdlineHook_debugTrap' DEBUG
	fi
}
export -f bg-sp-addCommand

# usage: bg-debugCntr [status]
# usage: bg-debugCntr trace [ on[:fileName] | off | status ]
# usage: bg-debugCntr vinstall status
# usage: bg-debugCntr vinstall <projectPath>
# usage: bg-debugCntr reinstall
# usage: bg-debugCntr vuninstall <projectPath>
# usage: bg-debugCntr vinstall -r <sandboxPath>
# usage: bg-debugCntr vuninstall -r <sandboxPath>
# this sets the user's bgtrace environment variable that effects scripts run in the current bash session
# This function has the same name as the external script. After the user sources the script into their
# bash terminal environment, subsequent invocations will be handled by the script and not the external
# file unless the full path to the external file is specified
function bg-debugCntr()
{
	# disable the DEBUG trap handler while we are in this function
	builtin trap - DEBUG

	local verboseFlag
	while [ $# -gt 0 ]; do case $1 in
		-v) verboseFlag="-v" ;;
		-hb|-hbo) break ;;
		*)  break; esac; shift; # simplified version of bgOptionsEndLoop
	done

	local cmd="${1:-status}"; shift
	local cmd2="${1:-status}"
	case $cmd:$cmd2 in
		sourceCore:*)  source /usr/lib/bg_core.sh; importCntr reloadAll --init ;;
		trace:*)       _traceCntr  "$@" ;;
		banner:*)      _bannerCntr "$@" ;;
		vinstall:*)    _vinstall   "$@" ;;
		vuninstall:*)  _vuninstall "$@" ;;
		reinstall:*)   _vinstall reinstall ;;
		codeGrep:*)    _codeGrep   "$@" ;;
		tags:*)        _tagsGrep   "$@" ;;
		debugger:*)    _debugger   "$@" ;;
		listCodeFiles:*) (
			bgTracingBanner=""
			source /usr/lib/bg_core.sh --minimal
			bgListAllInstalledCodeFiles
		) ;;
		utils:termIdent)
			local -A pidsByTty
			local pid tty pids; while read -r pid tty; do
				pidsByTty[${tty:-notty}]+="${pidsByTty[${tty:-notty}]:+,}$pid"
				pids+=("$pid")
			done < <(ps  -C bash  -o pid=,tty=)
			for tty in "${!pidsByTty[@]}"; do
				[ -e "/dev/$tty" ] && echo -en "\e]0;Temp Ident: pid= ${pidsByTty[$tty]} tty= /dev/$tty\a" > /dev/$tty
			done

			echo "the titles of these bash terminal windows owned by you have temporarily been changed to identify their pid and tty"
			ps -f --pid "${pids[@]}"
			;;
		-hb:*|-hbo:*)    _bg-debugCntrBC "$@" ;;
		status:*)
			while [ $# -gt 0 ]; do case $1 in
				-v) verboseFlag="-v" ;;
				*)  break; esac; shift; # simplified version of bgOptionsEndLoop
			done
			[ ! "$bgHostProductionMode" ] && bgHostProductionMode="$(source /usr/lib/bg_core.sh --queryMode; echo $bgHostProductionMode)"
			if [ "$	bgHostProductionMode" == "production" ]; then
				cat <<-EOS
				 	This host is currently in production mode and therefore development features will not work with any installed
				 	scripts. If you have admin privilege on this host you can put it in development mode by creating the file
				 	/etc/bgHostProductionMode with the contents 'mode=development'
				EOS

			else
				_traceCntr  status $verboseFlag
				_vinstall   status $verboseFlag
				_bannerCntr status $verboseFlag
				_debugger   status $verboseFlag
				_bashComandHooks status $verboseFlag
				echo "HostProductionMode   : $bgHostProductionMode"

				# If we are running as the external script as opposed to the sourced function, dev features are not installed
				if [ "$bgDebugCntrRunMode" == ""extScript"" ]; then
					cat <<-EOS
					Developement Features: off
					 	Development and Debugging features are not currently installed in this terminal but you can install them by
					 	sourceing this command instead of running it. This only has to be done once per terminal and then you can
					 	and should run this command without the 'source' prefix.
					 	Run the following command to install development and debugging features.

					 		   source $(basename $0)

					EOS
				else
					echo "Developement Features: installed"
					echo
				fi
			fi
			;;
		*) _assertError "unknown sub command '$cmd' '$cmd2'" ;;
	esac

	# if this feature is turned on, re-enable the DEBUG trap handler
	if [ "$bgBashCmdHookFeature" ]; then
		builtin trap 'cmdlineHook_debugTrap' DEBUG
	fi
}
export -f bg-debugCntr
[ -r /usr/lib/bg_bashCompletion.sh ] && source /usr/lib/bg_bashCompletion.sh
! type -t _bgbc-complete-viaCmdDelegation &>/dev/null && [ -r /usr/lib/bg_bashCompletion.sh ] && source /usr/lib/bg_bashCompletion.sh
complete -F _bgbc-complete-viaCmdDelegation bg-debugCntr


# This is the bash command line completion function for the bg-debugCntr entry point
function _bg-debugCntrBC()
(
	# note that this function uses () instead of {} so that we can source bg_core.sh without it
	# being permanent
	local bgTracingBanner=""
	source /usr/lib/bg_core.sh --minimal
	import bg_outOfBandScriptFeatures.sh ;$L1;$L2


	local words cword cur prev optWords posWords posCwords
	parseForBashCompletion --compat2 words cword cur prev optWords posWords posCwords "$@"

	local cmd1="${posWords[1]}"

	case $cmd1:$posCwords in
		*:1) echo "trace vinstall vuninstall reinstall status codeGrep listCodeFiles tags banner debugger utils sourceCore" ;;

		trace:2)
			local cmd2="${posWords[2]}"
			local colonCount="${cmd2//[^:]}"
			case ${cmd2%:*}:${#colonCount} in
				*:0) echo "status off on: bashCompOpts: \$(nextBreakChar :)	" ;;
				on:1)
					echo "\$(cur:${cmd2#on:})"
					echo "1 2 tty stderr stdout file: winNew win"
					ls /tmp/bgtrace.win?.cntr 2>/dev/null | sed  's|/tmp/bgtrace[.]||; s|[.]cntr||'
					;;
				on:file:*)
					echo "\$(cur:${cmd2#on:file:})"
					echo "\$(_fileDir)"
					;;
				bashCompOpts:*)
					echo "\$(cur:${cmd2#bashCompOpts:})"
					echo "verbose terse cachingOff cachingOn"
					;;
			esac
			;;

		utils:2)  echo "termIdent" ;;
		banner:2) echo "> on off" ;;
		vinstall:2) echo "status" ;;&
		vinstall:*)
			if [ "$cur" ] && [[ ! "status" =~ ^$cur ]]; then
				 echo "\$(doDirs)"
			 else
				 ls -1 -d */
				 echo "<projectFolders> reinstall"
			fi
			;;
		vuninstall:2) echo "all status" ;;&
		vuninstall:*)
			echo "<vInstalledProjects>"
			echo "$bgVinstalledPaths:" | tr ":" "\n" | sed -e 's|.*/|   |'
			;;
		codeGrep:*)
			case $prev in
				-A) echo "<number_lines_after> 1 2 3"; return ;;
				-B) echo "<number_lines_before> 1 2 3"; return ;;
				-C) echo "<linesType> onlyComments codeOnly tagsOnly"; return ;;
				-O) echo "<output_mode> summary matchingFiles"; return ;;
				-T) echo "<TAG> CRITICALTODO TODO SECURITY DEPRECIATED UPDATE BGENV OBSOLETE NOTE AWKLIB DOMCONFIG"; return ;;
			esac
			[ $posCwords -eq 2 ] || [[ "$prev" =~ ^- ]] && echo "-C -A -B -O -T -t -l -i <regexSearchExpr>"
			;;
		tags:2)
			echo "<TAG> CRITICALTODO TODO SECURITY DEPRECIATED UPDATE BGENV OBSOLETE NOTE AWKLIB DOMCONFIG"
			;;

		debugger:2) echo "on off status bashCmdHooks" ;;
		debugger:*)
			case ${posWords[2]}:$((posCwords-2)) in
				on:1)
						if [[ ! "$cur" =~ : ]]; then
							echo "integrated:%3A remote:%3A <dbgID>"
						else
							dbgDriver="${cur%%:*}"
							cur="${cur#*:}"
							echo "\$(cur:$cur)"
							case $dbgDriver in
								integrated) echo "<ttyDev> cuiWin /dev/pts/" ;;
								remote) echo "<remoteDbgInstancePipe> cuiWin " ;;
							esac
						fi
						;;
				on:2)  echo "<startingPoint> stopOnLibInit stopOnFirstScriptLine " ;;
				bashCmdHooks:*)
					case ${posWords[3]}:${posWords[4]}:$((posCwords-2)) in
						*:*:1) echo "on off status trace" ;;

						trace:*:2) echo "on off status" ;;
						trace:on:*) echo "\$(usingListmode ,) b4Cmdline b4SimpleCmd afterSimpleCmd afterCmdline" ;;
					esac
					;;
			esac
			;;
	esac
	exit
)
export -f _bg-debugCntrBC





#################################################################################################################################
# Sub Command Functions
# these implement the various sub commands of bg-debugCntr


# usage: _traceCntr [ on[:fileName] | off | status | bashCompOpts:[verbose|terse] ]
# this sets the user's bgtrace environment variable that effects scripts run in the current bash session
function _traceCntr()
{
	local quietFlag
	while [ $# -gt 0 ]; do case $1 in
		-q)   quietFlag="-q" ;;
		*)  break; esac; shift; # simplified version of bgOptionsEndLoop
	done

	local cmd="${1:-status}"; shift
	case $cmd in
		on*) assertBgDebugEnvironmentIsActive
			[ "$bgTracingOn" ] && _traceCntr -q off
			if [[ "$cmd" =~ ^on:win ]]; then
				_traceCntr openWin "${cmd#on:}"
			else
				export bgTracingOn="$cmd"
			fi
			shopt -s extdebug
			[ ! "$quietFlag" ] && _traceCntr status
			;;
		off) assertBgDebugEnvironmentIsActive
			if [[ "$bgTracingOn" =~ ^on:win[0-9] ]]; then
				_traceCntr closeWin "${bgTracingOn#on:}"
			fi
			shopt -u extdebug
			export bgTracingOn=""
			unset bgTracingOn
			[ ! "$quietFlag" ] && _traceCntr status
			;;
		status)
			# if the user sets bgTracingOn directly to winNew, then we need to call this outside the ()
			[[ "$bgTracingOn" =~ ^(on:)?(winNew)$ ]] && _traceCntr openWin "${bgTracingOn#on:}"

			(
				bgTracingBanner=""
				source /usr/lib/bg_core.sh --minimal

				if ! bgtraceIsActive; then
					echo "BGTracing status     : disabled"
				elif touch $_bgtraceFile 2>/dev/null; then
					echo "BGTracing status     : desination='$_bgtraceFile' (bgTracingOn='$bgTracingOn')"
				else
					echo "BGTracing status     : desination='$_bgtraceFile' error: '$_bgtraceFile' is not writable"
				fi
			)
			;;
		bashCompOpts:*)
			declare -gA _bgbcData
			local option="${cmd#bashCompOpts:}"
			case $option in
				cachingOff) _bgbcData[noCache]="1" ;;
				cachingOn)  _bgbcData[noCache]="" ;;
				verbose)
					assertBgDebugEnvironmentIsActive
					_bgbcData[tracingDetail]="verbose"
					_bgbcData[noCache]="1"
					! type -t bgtraceVars &>/dev/null && echo -e \
						"\n\twarning: in order to see verbose output for completion, you need to 'source /usr/lib/bg_core.sh' in this terminal\n"
					;;
				terse)
					assertBgDebugEnvironmentIsActive
					_bgbcData[tracingDetail]=""
					_bgbcData[noCache]=""
					;;
				*) _assertError "unknown option '$option'"
			esac
			;;
		openWin)
			local win winTraceFile
			case ${1:-winNew} in
				win[0-9]) win="$1"  ;;
				win)      win="out" ;;
				winNew)
					local i; for ((i=0; i<10; i++)); do
						[ ! -e ${cuiWinCntrFilePrefix}$win.cntr ] && { win="win$i"; break; }
					done
					[ ! "$win" ] && _assertError "
						no available win communication pipes were found. looking for one of these that do not yet exist -- '/tmp/bgtrace.win{0..9}.cntr'
					"
					;;
				*) _assertError "invalid bgtrace window identifier. Expecting win[0-9]|winNew|win but got '$1'" ;;
			esac
			winTraceFile="/tmp/bgtrace.$win"
			touch "$winTraceFile" || _assertError "file '$winTraceFile' can not be used as a trace file because it is not writable"
			[ "$win" ] && [ "$winTraceFile" ] && (
				source /usr/lib/bg_core.sh
				import bg_cuiWin.sh ;$L1;$L2
				local tty; cuiWinCntr -R tty "$win" open || assertError -v win "failed to open cuiWin '$win'"
				cuiWinCntr "$win" tailFile "$winTraceFile" || assertError -v win -v winTraceFile "failed to tail '$winTraceFile' in cuiWin '$win'"
			) && declare -gx bgTracingOn="on:${win/%out/win}"
			;;
		closeWin)
			local win="$1"
			[ "$win" ] && (
				source /usr/lib/bg_core.sh
				import bg_cuiWin.sh ;$L1;$L2
				cuiWinCntr "$win" close || assertError -v win "failed to close cuiWin '$win'"
			)
			;;
		*) _assertError "unknown command '$cmd'"
	esac
}
export -f _traceCntr


# usage: _traceCntr [ on[:fileName] | off | status ]
# this sets the user's bgtrace environment variable that effects scripts run in the current bash session
function _bannerCntr()
{
	local cmd="${1:-status}"
	case $cmd in
		on) assertBgDebugEnvironmentIsActive
			export bgTracingBanner="on"
			_bannerCntr status
			;;
		off)assertBgDebugEnvironmentIsActive
			export bgTracingBanner=""
			unset bgTracingBanner
			_bannerCntr status
			;;
		status)
			if [ "$bgTracingBanner" ]; then
				echo "Banner Status        : on"
			else
				echo "Banner Status        : off"
			fi
			;;
	esac
}
export -f _bannerCntr


# usage: _vinstallStatus
function _vinstallStatus()
{
	local verboseFlag
	while [ $# -gt 0 ]; do case $1 in
		-v) verboseFlag="-v" ;;
		*)  break; esac; shift; # simplified version of bgOptionsEndLoop
	done
	if [ "$bgVinstalledPaths" ]; then
		echo "VIinstall Status     : ${bgVinstalledSandbox:-one or more projects are vinstalled. use -v to enumerate them}"
		if [ "$verboseFlag" ]; then
			echo "   affected environment vars: PATH, MANPATH, AWKPATH, bgLibPath and bgDataPath"
			echo "   vinstalled projects: "
			echo "$bgVinstalledPaths:" | tr ":" "\n" | sed -e 's/./      &/; /^[[:space:]]*$/d'
		fi

	else
		echo "VIinstall Status     : none"
	fi
}
export -f _vinstallStatus


# usage: _vinstallPathProcessor -R <foldersVar> -S <sandboxFolderVar> [-r] [<path> [..<pathN>]]
# This processes the path arguments for the _vinstall and _vuninstall functions to create the expanded project folder list and
# the sandbox path if one is specified
# Params:
#    <pathN> : 0 or more paths of sandbox or package projects that will be acted on
# Options:
#    -R <foldersVar> : an array var to return the expanded project folder list
#    -S <sandboxFolderVar> : a variable that will return the sandbox root folder if one is specified.
#    -r : if a folder is neither a sandbox nor package project, this will determine if the path will be descended to find child
#         project folders
#    -e : (expand). expand each project folder and sandbox folder into its full, absolute path. vinstall wants this but vuninstall does not.
function _vinstallPathProcessor()
{
	local recurse defaultPathType="package" verboseFlag path foldersVar sandboxFolderVar expandFlag
#echo "$@"
	while [ $# -gt 0 ]; do case $1 in
		-v)   verboseFlag="-v" ;;
		-r)   recurse="-r"; defaultPathType="sandbox" ;;
		-e)   expandFlag="-e" ;;
		-R)   foldersVar="$2"; shift ;;
		-S)   sandboxFolderVar="$2"; shift ;;
		*)  break;
	esac; shift; done
# echo "$@"
# echo
# echo "foldersVar='$foldersVar'"
# echo "foldersVar='$foldersVar'"
# _assertError testMode


	# expand the list of folders to be installed taking into account the types of folders they are
	# -r only effects folders that do not have a .bg-sp/config file
	while [ $# -gt 0 ]; do
		path="$1"; shift
		[ -d "$path" ] || _assertError "error: '$path' is not a folder path" || continue
		[ "$expandFlag" ] &&  path=$(cd  ${path:-.}; pwd)

		# get pathType for this folder using -r option to determine unknown types
		pathType="$(awk -F= '$1=="projectType" {print $2}' $path/.bg-sp/config 2>/dev/null)"
		[ ! "$pathType" ] && [ -f "$path/.bg-sp/config" ] && pathType="package" # if .bg-sp/config exists the default projectType is 'package'
		[ ! "$pathType" ] && pathType="$defaultPathType" # if it does not exist, the default is based on -r

		case $pathType in
			sandbox)
				[ "${!sandboxFolderVar}" ] && _assertError "Only one sandbox folder can be vinstalled in any given terminal window."
				printf -v "$sandboxFolderVar" "%s" "$path"
				local folderValue; for folderValue in $(ls -d  ${path%/}/*/.bg-sp/ 2>/dev/null); do
					folderValue="${folderValue%/.bg-sp*}"
					eval $foldersVar'+=("$folderValue")'
				done
				;;
			package)
				eval $foldersVar'+=("$path")'
				;;
		esac
	done
}

# usage: _vinstall [reinstall]
# usage: _vinstall status
# usage: _vinstall [-r] <path>
# virtually install a project folder or set of project folders from a sandbox
# insert the folder into the path environment first so that the commands in that folder
# supercede others in system folders. E.G. a script project package maybe installed
# but when you are making changes you can use this command to test the versions of the
# commands you are editing
function _vinstall()
{
	local recurse verboseFlag
	while [ $# -gt 0 ]; do case $1 in
		-v)   verboseFlag="-v" ;;
		-r)   recurse="-r" ;;
		*)  break;
	esac; shift; done

	if [ "$1" == "status" ]; then
		shift
		_vinstallStatus $verboseFlag "$@"
		return
	fi

	assertBgDebugEnvironmentIsActive

	local gdeps folders folder status sandboxFromFolderList

	# default is to reinstall the projects that are already vinstalled
	if [ $# -eq 0 ] || [ "${1:-reinstall}" == "reinstall" ]; then
		echo "re-installing all projects registered in \$bgVinstalledPaths"
		IFS=":" read -a folders <<<$bgVinstalledPaths

		[ "$bgVinstalledSandbox" ] && ( (
			cd "$bgVinstalledSandbox"
			[ -x makeCtags.sh ] && ./makeCtags.sh &>/dev/null
		)  & )
		shift
	fi


	_vinstallPathProcessor -e -R folders -S sandboxFromFolderList $recurse "$@"

	# if the user is vinstalling a sandbox folder, we record it in the ENV separately and it activates some special features
	# the sandbox's project folders are already in $folders
	if [ "$sandboxFromFolderList" ]; then
		declare -gx bgVinstalledSandbox="$sandboxFromFolderList"
	fi


	# # expand the list of folders to be installed taking into account the types of folders they are
	# # -r only effects folders that do not have a .bg-sp/config file
	# while [ $# -gt 0 ]; do
	# 	path="$1"; shift
	# 	[ -d "$path" ] || _assertError "error: '$path' is not a folder path" || continue
	#
	# 	# get pathType for this folder using -r option to determine unknown types
	# 	pathType="$(awk -F= '$1=="projectType" {print $2}' $path/.bg-sp/config)"
	# 	[ ! "$pathType" ] && [ -f "$path/.bg-sp/config" ] && pathType="package" # if .bg-sp/config exists the default projectType is 'package'
	# 	[ ! "$pathType" ] && pathType="$defaultPathType"
	#
	# 	case $pathType in
	# 		sandbox)
	# 			[ "${bgVinstalledSandbox}" ] && _assertError "The sandbox '${bgVinstalledSandbox}' is already installed in this terminal"
	# 			declare -gx bgVinstalledSandbox="$path"
	# 			for folder in $(ls -d  ${path%/}/*/.bg-sp/ 2>/dev/null); do
	# 				folder="${folder%/.bg-sp*}"
	# 				folders=("${folders[@]}" "$folder")
	# 			done
	# 			;;
	# 		package)
	# 			folders=("${folders[@]}" "$path")
	# 			;;
	# 	esac
	# done


	# do the vinstall on each folder in the list,
	for folder in "${folders[@]}"; do
		local fullpath=$(cd  ${folder:-.}; pwd)
		local projName="${fullpath##*/}"

		# the package name is typically the foldername but the deb control file has the the real name
		local pkgName="$(awk '/^Package:/ {s=$0; sub("^Package:[ \t]*","",s); print s}' $fullpath/debControl/control 2>/dev/null )"
		[ ! "$pkgName" ] && pkgName="${fullpath##*/}"

		# set "status" and "addedFlag" to indicate if this project was already vinstalled
		local addedFlag=""
		if [[ ":${PATH}:" =~ :$fullpath: ]]; then
			status="updated"
		else
			status="added"
			addedFlag="1"
		fi

		# make sure the fullpath appears in each of these paths but dont add it twice.
		[[ ! ":${PATH}:"                =~ :$fullpath: ]] && export PATH="$fullpath:$PATH"
		[[ ! ":${MANPATH}:"             =~ :$fullpath: ]] && export MANPATH="$fullpath:$MANPATH"
		[[ ! ":${AWKPATH}:"             =~ :$fullpath: ]] && export AWKPATH="$fullpath:${AWKPATH:-$(awk 'BEGIN {print ENVIRON["AWKPATH"]}')}"
		[[ ! ":${bgLibPath}:"           =~ :$fullpath: ]] && export bgLibPath="$fullpath:$bgLibPath"
		[[ ! ":${bgDataPath}:"          =~ :$fullpath: ]] && export bgDataPath="$fullpath:$bgDataPath"
		[[ ! ":${bgVinstalledPaths}:"   =~ :$fullpath: ]] && export bgVinstalledPaths="$fullpath:$bgVinstalledPaths"
		[[ ! ":${bgInstalledPkgNames}:" =~ :$pkgName:  ]] && export bgInstalledPkgNames="$pkgName:$bgInstalledPkgNames"

		# if we are vinstalling the project with bg_core.sh, cp it to the system folder if the same version
		# is not already there.  bg_core.sh is the boot strap for all scripts so it must be in the
		# well known location
		if [ -f $fullpath/bg_core.sh ] && ! diff -q $fullpath/bg_core.sh /usr/lib/bg_core.sh &>/dev/null; then
			sudo -p "update boot strap lib [sudo] " cp $fullpath/bg_core.sh /usr/lib/bg_core.sh
		fi

		# if we are vinstalling our project, then re-source ourselves.
		# if this _vinstall function that we are executing changes, it might be a problem but this is
		# still useful because we can pick up the changes to the other features
		[ -f $fullpath/bg-debugCntr ] && { source $fullpath/bg-debugCntr "noop"; }
		[ -f $fullpath/bg_bashCompletion.sh ] && source $fullpath/bg_bashCompletion.sh

		# source the project's BC scripts and count them for the status output at the end
		local count=0
		for f in $(ls "$fullpath/data/bashCompletion/"* 2>/dev/null); do
			source "$f"
			(( count++ ))
		done

		# record the dependencies
		local deps="$(awk '$1~"^Depends:" {FS=",";sub("^Depends:","",$0); for (i=2; i<NR; i++) {s=$i; sub("\\(.*$","",s); print s}}' $fullpath/debControl/control 2>/dev/null)"
		gdeps="$gdeps${gdeps:+ }$deps"

		# update the funcman man pages in the background
		if [ ! "$bgVinstallInhibitPostProcessing" ]; then
		( (
			export bgTracingBanner=""
			cd "$fullpath"
			which bg-sp-funcman &>/dev/null && bg-sp-funcman run -qq
		) & )
		fi


		case $status in
			added)   printf "virtually installed %3s commands from %s\n" "$count" "$projName" ;;
			updated) printf "updating %3s virtually installed commands from %s\n" "$count" "$projName" ;;
		esac
	done


	# update some things that would be normally done in a post install script
	if [ ! "$bgVinstallInhibitPostProcessing" ]; then
		(progressDisplayType=null bg-plugins -fr &>/dev/null &)
		(progressDisplayType=null bg-domData configSchema -r -f &>/dev/null &)
	fi


	# report if there are any uninstalled dependencies
	[ "$addedFlag" ] && __bgCheckForMissingDeps "$gdeps"

}
export -f _vinstall



# usage: _vuninstall [-r] <path>
# undo the _vinstall effect when you are done
function _vuninstall()
{
	local recurse verboseFlag folders sandboxFromFolderList
	while [ $# -gt 0 ]; do case $1 in
		-v)   verboseFlag="-v" ;;
		-r)   recurse="-r" ;;
		*)  break;
	esac; shift; done

	if [ "$1" == "status" ]; then
		_vinstallStatus "$@"
		return
	fi

	assertBgDebugEnvironmentIsActive

	# implement no <path> or the keyword "all" by re-calling ourseves to vuninstall each of the currently installed projects.
	if [ "${1:-all}" == "all" ]; then
		echo "uninstalling all projects registered in \$bgVinstalledPaths"
		local installedProjectPaths; IFS=":" read -a installedProjectPaths <<<$bgVinstalledPaths
		_vuninstall "${installedProjectPaths[@]:-status}"
		unset bgVinstalledSandbox
		return
	fi

	_vinstallPathProcessor -R folders -S sandboxFromFolderList $recurse "$@"

	if [ "$sandboxFromFolderList" ]; then
		[ "$sandboxFromFolderList" == "$bgVinstalledSandbox" ] || _assertError "The sandbox you specified to vuninstall is not currently installed. \n\tcurrently installed sandbox='$bgVinstalledSandbox' \n\tcthe sandbox specified='$sandboxFromFolderList'"
		unset bgVinstalledSandbox
	fi


	# # TODO: this should use the same folder expansion block as _vinstall. make it a function and call from both places
	# if [[ "$1" =~ ^-r ]]; then
	# 	local path=""
	# 	[ -d "$2" ] && path="$2"
	# 	for folder in $(ls -d  $path/*/.bg-sp/ 2>/dev/null); do
	# 		folder="${folder%/.bg-sp*}"
	# 		_vuninstall "$folder"
	# 	done
	# 	return
	# fi

	local projFolder
	for projFolder in "${folders[@]}"; do

		# when we uninstall, the user can specify the project name instead of a path to the folder
		local paths; IFS=":" read -a paths <<<$bgVinstalledPaths
		local path; for path in "${paths[@]}"; do
			if [[ "${path%/}" =~ /${projFolder%/}$ ]]; then
				projFolder="$path"
				break
			fi
		done

		# this function is needed to handle the trick case that the path we are removing is a subset of another path
		function __subtractPathElement()
		{
			local s=":${1}:"
			s="${s//:$2:/:}"
			s="${s//::/:}"
			s="${s#:}"
			s="${s%:}"
			echo "$s"
		}

		local pkgName="$(awk '/^Package:/ {s=$0; sub("^Package:[ \t]*","",s); print s}' $projFolder/debControl/control 2>/dev/null )"
		[ ! "$pkgName" ] && pkgName="${projFolder##*/}"

		if [[ ":${PATH}:" =~ :$projFolder: ]] || [[ ":${MANPATH}:" =~ :$projFolder: ]] || [[ ":${bgLibPath}:" =~ :$projFolder: ]]; then
			echo "removed '$projFolder' from PATH, MANPATH, AWKPATH, bgLibPath and bgDataPath"
		else
			echo "skipped '$projFolder' was already removed"
		fi

		export PATH="$(__subtractPathElement "$PATH" "$projFolder")"
		export MANPATH="$(__subtractPathElement "$MANPATH" "$projFolder")"
		export AWKPATH="$(__subtractPathElement "$AWKPATH" "$projFolder")"
		# CRITICALTODO: update makefile to put .awk files in /usr/share/awk
		export bgLibPath="$(__subtractPathElement "$bgLibPath" "$projFolder")"
		export bgDataPath="$(__subtractPathElement "$bgDataPath" "$projFolder")"
		export bgVinstalledPaths="$(__subtractPathElement "$bgVinstalledPaths" "$projFolder")"
		export bgInstalledPkgNames="$(__subtractPathElement "$bgInstalledPkgNames" "$pkgName")"
	done
}
export -f _vuninstall





# usage: _tagsGrep <tag> [<regex>]
# grep the installed script code from any installed or vinstalled package project
function _tagsGrep()
(
	bgTracingBanner=""
	source /usr/lib/bg_core.sh --minimal
	local tmp
	local -a opts=()
	while [ $# -gt 0 ]; do case $1 in
		-A*|-B*|-O*) opts=("${1:0:2}" "$(bgetopt "$@")") && shift ;;
		-*) opts=("${1}") ;;
		*)  bgOptionsEndLoop "$@" && break; set -- "${bgOptionsExpandedOpts[@]}"; esac; shift;
	done;
	[ $# -gt 0 ] || _assertError "tag name is a required parameter" || return 2
	_codeGrep "${opts[@]}" -T "$@"
)
export -f _tagsGrep


# usage: _codeGrep
# grep the installed script code from any installed or vinstalled package project
function _codeGrep()
(
	bgTracingBanner=""
	source /usr/lib/bg_core.sh --minimal

	local outMode="summary"
	local tagsExpression=""
	local commentMode=""
	local passThruOpts=()
	local preColorize="on"
	local preLineFormat="on"
	local suppressPrefix=""
	local truncateFlag=""

	# Handle the command line options as defined by the "getopts" unix/linux standard.
	# Specify the supported options in the optSpecs. 'x:' requires and argument.
	optSpecs="tT:C:A:B:O:livh"
	while getopts "$optSpecs" flag; do case $flag in
		T) tagsExpression="#[A-Z0-9:[:space:]]*${OPTARG}[A-Z0-9:[:space:]]*:" ;;
		t) truncateFlag="-t" ;;
		-) break ;;
		C) commentMode=${OPTARG} ;;
		O) outMode=${OPTARG} ;;
		l) outMode="matchingFiles" ;;
		h) suppressPrefix="-h"  ;;
		v) passThruOpts+=("-${flag}${OPTARG}")  ;;
		A) passThruOpts+=("-${flag}${OPTARG}")  ;;
		B) passThruOpts+=("-${flag}${OPTARG}")  ;;
		i) passThruOpts+=("-${flag}${OPTARG}")  ;;
		?) passThruOpts+=(-$flag)  ;;
	esac; done; shift $((OPTIND-1)); unset OPTIND

	local codeFiles="$(bgListAllInstalledCodeFiles)"

	case $outMode in
		# the awk script branches on outMode to implement this option
		summary)       : ;;
		matchingFiles) preColorize="skip" ;;
		*)             assertError "unknown output format specified in '-O $outMode' option" ;;
	esac

	[[ "${commentMode:-empty}" =~ ^(onlyComments|codeOnly|tagsOnly|empty)$ ]] || assertError "unknown comment mode '$commentMode'. Expected one of onlyComments|codeOnly|tagsOnly"

	[ "$commentMode" == "tagsOnly" ] && tagsExpression="#[[:space:]]*[A-Z][A-Z0-9]*:"
	local tagsExpressionSep=""; [ "$tagsExpression" ] && [ "$1" ] && tagsExpressionSep=".*"

	local windowWidth=$(( [ -t 1 ] || [ -t 2 ] ) && tput cols || echo 1000)

	# TODO: make an awk library string that both _codeGrep and funcman can use to keep track of file sections and linetypes
	# TODO: I started adding file, and section level classification but then realized that codeGrep only sees the reduced output of grep so it can not do that. Move this algorithm to funcman or a new tool in the funcman space of full source scanning ctags, etc...
	grep "${passThruOpts[@]}" --color=never -n -- "${tagsExpression}${tagsExpressionSep}$1" $codeFiles \
		| $(cmdSw $preLineFormat) awk -v regex="${tagsExpression}${tagsExpressionSep}$1" -v commentMode="$commentMode" -v suppressPrefix="$suppressPrefix" -v windowWidth="$windowWidth" -v truncateFlag="$truncateFlag" '
			function bgtrace(s) {
				print s >> "/tmp/bgtrace.out"
			}
			BEGIN {
				csiHiRed=sprintf("'"$csiHiRed"'")
				csiFontReset=sprintf("'"$csiFontReset"'")
				csiWhite=sprintf("'"$csiWhite"'")
			}


			BEGINFILE {
				# we currently pipe grep into this function so awk is reading stdin and not files so BEGINFILE is not useful
			}
			FNR==1 {
				if (fileType ~ /lib|command/ && $1 ~ /^#!/) {
					sub(".*/","", $0)
					fileType=fileType":"$0
				}
			}
			{
				# parse the grep output format. Context lines vs matching lines and file/lineNo prefix vs content
				# Output:
				#      lineType=context|data
				#      filePart=<filename>
				#      lineNo=<lineNumber>
				filePart=$0; sub("[-:][0-9]*[-:].*$","", filePart);
				contentPart=substr($0,length(filePart)+1)
				lineType=(substr(contentPart,1,1)=="-")?"context":"data"
				lineNo=contentPart; sub("^[-:]","", lineNo); sub("[-:].*$","", lineNo);
				colNo=(match(contentPart, regex)?RSTART:1);
				sub("^[-:][0-9]*[-:]","", contentPart);


				srcFile=filePart; sub("^.*/|[(].*$","",srcFile)
				if (srcFile != srcFileLast) {
					# stateful sections are reset each time we enter a new file
					sectionType="global"
					switch (srcFile) {
					 	case /^.._.*[.]sh$/:          fileType="lib"; break;
						case /^.*[.]creqConfig$/:     fileType="plugin:creqConfig"; break;
						case /^.*[.]creqProfile$/:    fileType="plugin:creqConfig"; break;
						case /^.*[.]standards$/:      fileType="plugin:standards"; break;
						case /^.*[.]collect$/:        fileType="plugin:collect"; break;

						case /^.*[.]bgGitFeature$/:   fileType="plugin:bgGitFeature"; break;
						case /^.*[.]domWiki$/:        fileType="plugin:domWiki"; break;
						case /^.*[.]pluginType$/:     fileType="plugin:pluginType"; break;
						case /^.*[.]rbacPermission$/: fileType="plugin:rbacPermission"; break;
						case /^[^.]*$/:               fileType="command"; break;
				 	}

					srcFileLast=srcFile
				}
#
#
# 				# maintain a running section type so that we know what kind of content we are in.
# 				# this is a state machine. The rest state is "global". From there, various patterns can change the state to something else
# 				# and from those places, a pattern specific to it can return it to the "global state"
# 				# the state is reset to "global each time a new file is started"
# 				switch (sectionType) {
# 					case "global":
# 						switch (contentPart) {
# 							case /^[[:space:]]*function[[:space:]]/:                          sectionType="function"      ; break
# 							case /^[[:space:]]*#[[:space:]]usage:[[:space:]]/:                sectionType="manPage"       ; break
# 							case /^[[:space:]]*#[[:space:]]?(funcman)?[[:space:]]?MAN[(]/:    sectionType="manPage"       ; break
# 							case /^[[:space:]]*#[[:space:]]*AWKLIB([[:space:]]|:)/:           sectionType="awkCode:lib"   ; break
# 							case /^[[:space:]]*[^#[:space:]].*(awk|bgawk|awkDataRunBuilder).*['\''][[:space:]]*$/: sectionType="awkCode:script"; break
# 							case /^[[:space:]]*[^#[:space:]].*(awk|bgawk|awkDataRunBuilder).*\\$/: sectionType="awkStartContinue"; break
# 						}
# 					case "function": if (contentPart ~ /^}/)  sectionType="global"; break
# 					case "manPage":  if (contentPart !~ /^[[:space:]]*#/)  sectionType="global"; break
# 					case "awkStartContinue":
# 						switch (contentPart) {
# 							case /\\$/:                 sectionType="awkStartContinue"; break
# 							case /['\''][[:space:]]*$/: sectionType="awkCode:script"  ; break
# 							default:                    sectionType="global"          ; break
# 						}
# 						break;
# 					case /^awkCode/:  if (contentPart !~ /^[[:space:]]*#/)  sectionType="global"; break
# 				}


				# classify the line type
				if (lineType~"data" && contentPart~"^[[:space:]]*#")
					lineType=lineType"-comment"
				if (lineType~"data" && contentPart~"^[[:space:]]*[^#[:space:]]")
					lineType=lineType"-code"
				if (lineType~"context" && !lineNo)
					lineType=lineType"-separator"
				if (lineType~"comment" && contentPart~"#[[:space:]]*[A-Z][A-Z0-9]*[[:space:]]*:")
					lineType=lineType"-tag"

				# canonize the TAG format
				if (lineType ~ "tag") {
					if (match(contentPart, "#[[:space:]]*([A-Z][A-Z0-9]*)[[:space:]]*:", matches)) {
						tag=matches[1]
						sub("#[[:space:]]*"tag"[[:space:]]*:","# "csiHiRed""tag""csiFontReset" :", contentPart)
					}
				}

				#printf("%-13s %-7s %-13s %-13s %s\n", srcFile, fileType, sectionType, lineType, contentPart) >>"/tmp/codeGrepTest.data"

				# if this line does not match the requested content type, mark it for skipping
				if (commentMode) switch (commentMode":"lineType) {
					case "onlyComments:data-comment": break
					case "codeOnly:data-code":        break
					case "tagsOnly:data-comment-tag": break
					case ":.*":                       break
					default: skips[NR]=1
				}

				# reduce the filename
				# TODO: use the .bg-sp folder to identify the containing project
				fullFiles[NR]=filePart
				folderCount=0
				filename=filePart; sub("^.*[/]","", filename); filePart=substr(filePart, 1, length(filePart)-length(filename)-1)
				for (i=0; i<folderCount; i++) {
					folder=filePart; sub("^.*[/]","", folder); filePart=substr(filePart, 1, length(filePart)-length(folder)-1)
					filename=folder"/"filename
				}
				if (lineType~"context") gsub("."," ", filename)

				colNoOpt=(true)?":"colNo:""

				pad=(int(lineNo)<10?"   ":((int(lineNo)<100)?"  ":((int(lineNo)<1000)?" ":"")))
				fileWithLineNo=filename"("lineNo""colNoOpt"):"pad
				if (lineType~"separator") fileWithLineNo=""

				# record this line record. We buffer them to do some post processing in the end
				files[NR]=filename
				lineNos[NR]=lineNo
				colNos[NR]=colNo
				filesWithLineNo[NR]=fileWithLineNo
				content[NR]=contentPart
				lineTypes[NR]=lineType

				if (!skips[NR])
					matchingFiles[filename]++

				fileSumLen+=length(fileWithLineNo)
				fileLens[NR]=length(fileWithLineNo)
			}
			END {
				if ("'"$outMode"'"=="matchingFiles") {
					for (file in matchingFiles)
						printf("%3s : %s\n", matchingFiles[file], file)

				} else {

					fileAvgLen=fileSumLen/((NR>0)?NR:1)
					asort(fileLens)
					iggy=0
					iggy=int(NR*0.1)
					fileMaxLen=fileLens[NR-iggy]

					lineSetCount=0
					lastLineNo=999
					lineSetState=1
					for (i=1; i<=NR; i++) {
						if (lastLineNo+1 != lineNos[i] || lineTypes[i]~"separator") {
							if (!lineSetState && lineSetCount>1) {
								for (n=0; n<lineSetCount; n++)
									skips[lineSet[n]]=1
							}
							delete lineSet
							lineSetState=0
							lineSetCount=0
						}
						lastLineNo=lineNos[i]
						lineSet[lineSetCount++]=i
						if (!skips[i] && lineTypes[i]~"data")
							lineSetState=1
					}

					lastIsASeparator=0
					for (i=1; i<=NR; i++) {
						if (lastIsASeparator && lineTypes[i]~"separator")
							skips[i]=1
						if (!skips[i])
							lastIsASeparator=(lineTypes[i]~"separator")
					}

					debug=0
					for (i=1; i<=NR; i++) {
						if (debug || !skips[i]) {
							data=content[i]
							if (debug) data=skips[i]"| "lineTypes[i]
							gsub("^[[:space:]]*", "", data)
							prefix=filesWithLineNo[i]; if (suppressPrefix) {prefix=""; fileMaxLen=0}
							outline=sprintf(csiWhite"%*s"csiFontReset" %s", fileMaxLen,prefix, data)
							if (truncateFlag && length(outline)>windowWidth) {
								realLength=0
								realOut=""
								colorRegex=csiHiRed"|"csiFontReset"|"csiWhite
								gsub("[[]","\\[",colorRegex)
								match(outline, colorRegex)
								while (realLength<windowWidth) {
									# when the colors are turned off b/c output is not going to a terminal,
									# the colorRegex matches the empty string and RSTART will 1 and RLENGTH will be 0
									if (RSTART>0 && RLENGTH>0 && realLength+RSTART <= windowWidth) {
										realLength+=(RSTART-1)
										realOut=realOut""substr(outline,1,RSTART+RLENGTH-1)
										outline=substr(outline,RSTART+RLENGTH)
									} else {
										realOut=realOut""substr(outline,1,windowWidth-realLength-1)
										realLength=windowWidth
										outline=""
									}
									match(outline, colorRegex)
								}
								outline=realOut"+"
							}
							printf("%s"csiFontReset"\n", outline)
						}
					}
				}
			}' \
		| $(cmdSw $preColorize) grep  --color=always -E -- "${1}|$"
)
export -f _codeGrep



# usage: _debugger on [ <terminalID> [<firstBreakpoint>] ]
# usage: _debugger off|status
# Params:
#    <terminalID> : which tty the debugger cui should be done on
#           win : in a separate cuiWin (terminal emulator window) with the ID '$termID.debugger'
#           win[0-9] : in a separate cuiWin (terminal emulator window) with the ID 'win[0-9]'
#           tty : the script's terminal. The debugger UI will be intermixed with the script UI
#           bgtrace : in the bgtrace tty destination
#    <firstBreakpoint> : the breakpoint that will be set to determine where the bebugger will be first activated
#           stopOnLibInit : stops script execution on as soon as enough libraries have been sourced to run the debugger
#                This allows stepping through most of the library initiallization
#           stopOnFirstScriptLine : stops the script on the first line of the main script. This skips the initialization
#                of any libraries that the script imports before its first line.
function _debugger()
{
	local cmd="$1"; shift
	[ "${cmd:-status}" != "status" ] && assertBgDebugEnvironmentIsActive
	case ${cmd:-status} in
		on)	export bgDebuggerOn="on:${1} $2" ;;
		off)unset bgDebuggerOn ;;
		status)       echo "Debugger Status      : ${bgDebuggerOn:-off}" ;;
		bashCmdHooks) _bashComandHooks "${@:1}" ;;
	esac
}
export -f _debugger



# usage: _bashComandHooks on|off|status
# This manages a DEBUG trap and PROMPT_COMMAND to call onBeforeBashCmd and onAfterBashCmd hook functions
# Note that onBeforeBashCmd is executed in the shell's environment but onAfterBashCmd is executed
# in a subshell because bash does not allow it to run in its environment.
function _bashComandHooks()
{
	local verboseFlag
	while [ $# -gt 0 ]; do case $1 in
		-v) verboseFlag="-v" ;;
		*)  break; esac; shift; # simplified version of bgOptionsEndLoop
	done
	local cmd="$1"; shift
	[ "${cmd:-status}" != "status" ] && assertBgDebugEnvironmentIsActive
	local marker=$'#onBeforeBashCmd; '
	case ${cmd:-status} in
		on)	export bgBashCmdHookFeature=on
			local script; read -r -d "" script <<-EOS
				cmdlineHook_promtCmdHook
			EOS

			# if our script is not present the first will be false and the second will set \1 to the whole string.
			[[ "$PROMPT_COMMAND" =~ ^(.*)(${marker}.*${marker})(.*)$ ]] || [[ "$PROMPT_COMMAND" =~ ^(.*)(.*)(.*)$ ]]
			PROMPT_COMMAND="${BASH_REMATCH[1]}${BASH_REMATCH[1]:+$'\n'}${marker}"$'\n'"${script}"$'\n'"${marker}${BASH_REMATCH[3]:+$'\n'}${BASH_REMATCH[3]}"
			;;
		off)unset bgBashCmdHookFeature
			[[ "$PROMPT_COMMAND" =~ ^(.*)(${marker}.*${marker})(.*)$ ]] && PROMPT_COMMAND="${BASH_REMATCH[1]}${BASH_REMATCH[3]}"
			PROMPT_COMMAND="${PROMPT_COMMAND//$'\n'$'\n'/$'\n'}"
			[[ "$PROMPT_COMMAND" =~ ^$'\n'*$ ]] && PROMPT_COMMAND=""
			PROMPT_COMMAND='builtin trap - DEBUG; PROMPT_COMMAND=""'
			;;
		trace)
			subCmd="$1"; shift
			case $subCmd in
				on*)    cmdlineHook_traceingOn="$subCmd $*" ;;
				off)    cmdlineHook_traceingOn="off" ;;
				status) echo "cmdlin hook tracing is set to : ${cmdlineHook_traceingOn:-off}" ;;
			esac
			;;
		status)
			[ "$1" == "-v" ] && verboseFlag="-v"
			echo "  BashCmdHooks Status: ${bgBashCmdHookFeature:-off}"
			if [ "$bgBashCmdHookFeature" ]; then
				[[ "$PROMPT_COMMAND" =~ ^(.*)(${marker}.*${marker})?(.*)$ ]] || echo "   warning: PROMPT_COMMAND does not have the onBeforeBashCmd hook installed"
			else
				[[ "$PROMPT_COMMAND" =~ ^(.*)(${marker}.*${marker})(.*)$ ]] && echo "   warning: PROMPT_COMMAND has the onBeforeBashCmd hook installed"
			fi
			if [ "$verboseFlag" ]; then
				echo "  PROMPT_COMMAND=${PROMPT_COMMAND//$'\n'/$'\n'                 }"
			fi
			;;
	esac
}
export -f _bashComandHooks

# usage: cmdlineHook_debugTrap <whereCalledFrom>
# this is the system trap function for onBeforeBashCmd. We separate this and the logical onBeforeBashCmd so
# that this can maintain the system part of the mechanism and the onBeforeBashCmd can contain only the
# logical actions we want to add to the bash cmd hook.
# In particular, we synthesize a call to onBeforeBashCmd when the user enters an empty line which contains no
# bash simple commands and therefore does not cause the DEBUG trap to execute
# It calls the logical onBeforeBashCmd* callback(s) which is where you put features
function cmdlineHook_debugTrap()
{
	# the first thing we do must be to save the last exit code
	local last_exitCode="$?"

	# keep track of the value that this function will return at the end
	local dbgResult=0

	# uncomment out this tracing if debugging the bg-debugCntr sourced code
#	[[ ! "${FUNCNAME[@]: -1}" =~ ^(_man|_longopt|_minimal|_find|_completion_loader)$ ]] && printf "$((_dbgSeq++)) %5s %5s: prevEcode(%s): ${FUNCNAME[@]: -1} %s\n" "$$" "$BASHPID" "$last_exitCode" "$BASH_COMMAND" >> $(_bgtrace --getDestination).dbgTrace

	# this trap is meant to only operate on the simple commands typed on the shell prompt. When simple commands are sourced functions
	# like bash completion fucntions, we do not want to incur the overhead for each line of those functions so we return if the
	# function nesting level is >1. We cant turn off the trap or else we wont have an oportunity to turn it back on before the command
	# is executed. Use-case: cd <tab><tab>
	(( ${#FUNCNAME[@]} > 1 )) && return

	# now that we know we are being triggered for real, record the saved code in the global bgBASH_COMMAND_exitCode
	bgBASH_COMMAND_exitCode="$last_exitCode"

	# not sure if we have to turn off the DEBUG trap for the duration of our function but we do it
	builtin trap - DEBUG

	# detect and suppress traps that we dont want to process.
	#    1) when regular code turns off the debug trap with 'builtin trap - DEBUG', we dont want to process that simple cmd
	#    2) when functions sourced in the shell get called, we this trap is not meant to track them
	if ( [[ "$BASH_COMMAND" =~ ^[[:space:]]*builtin[[:space:]]*trap[[:space:]]*-?[[:space:]]*DEBUG[[:space:]]*$ ]] ) \
	   || [ "$BASH_COMMAND" == "cmdlineHook_promtCmdHook" ] \
	   || (( ${#FUNCNAME[@]} > 1 )) ; then
		# put code here that ends a run of DEBUG trapping
		return 0
	fi

	# the first DEBUG trap invocation after the user hits enter, will get the full cmdline from the
	# bash history mechanism and fire the preCmdline event before moving on to the simple cmd about
	# to run.
	if ((bgBASH_COMMAND_INDEX==0)); then
		local cmdID; read -r cmdID bgBASH_COMMAND_LINE < <(history 1)
		# for the pre and pos cmdline hooks, bgBASH_COMMAND is the entire cmd line typed by the user
		bgBASH_COMMAND="$bgBASH_COMMAND_LINE"
		_fireCallbackList cmdlineHook_preCmdlineCallbackList DEBUG

	# synthesize a postSimpleCmd event for the last simple cmd that executed before. This does not run
	# the first time b/c we get called before each simple cmd so the first time there was no previous
	# cmd. This event will also get fired from the PROMPT_COMMAND hook so that it picks up the
	# last simple cmd ran
	else
		# bgBASH_COMMAND is still set from the last debug trap so it is the simple cmd that just finished
		_fireCallbackList cmdlineHook_postSimpleCmdCallbackList DEBUG
	fi

	# now fire the preSimpleCmd event for the new $BASH_COMMAND which is about to run
	bgBASH_COMMAND="$BASH_COMMAND"
	_fireCallbackList cmdlineHook_preSimpleCmdCallbackList DEBUG

	# count how many simple commands are executed as a result of this cmdline
	((bgBASH_COMMAND_INDEX++))

	if ([[ "$BASH_COMMAND" =~ BASH_REMATCH ]]); then
		eval ${BASH_COMMAND//BASH_REMATCH/rematch}
		dbgResult=1
	fi

	# re-enable the trap since the user might have typed a compound command and DEBUG trap is called
	# before each simple command
	if [ "$bgBashCmdHookFeature" ]; then
		builtin trap 'cmdlineHook_debugTrap' DEBUG
	fi
	return $dbgResult
}
export -f cmdlineHook_debugTrap


# usage: cmdlineHook_promtCmdHook
# This is the system callback executed by PROMPT_COMMAND after each command has finished running,
# right before bash displays the prompt
# It fires off any registered logical onAfterBashCmd* callback(s) which is where you put features
function cmdlineHook_promtCmdHook()
{
	bgBASH_COMMAND_exitCode="$?"
	# disable the DEBUG trap handler while we are in this function
	builtin trap - DEBUG

	# synthesize a preCmdline event for <enter> on an empty line. Technically there was no bash simple
	# command so the debug trap did not get called. It normally detects and fires the preCmdline event
	# but if it never ran for this command, we can do it at the top of the PROMPT_COMMAND hook
	if [  ${bgBASH_COMMAND_INDEX:-1} -eq 0 ]; then
		bgBASH_COMMAND=""
		_fireCallbackList cmdlineHook_preCmdlineCallbackList PROMPT_COMMAND

	# if at least one simple cmd ran, we need to do the post simple cmd event
	else
		# bgBASH_COMMAND is still set from the last debug trap so it is the simple cmd that just finished
		_fireCallbackList cmdlineHook_postSimpleCmdCallbackList DEBUG
	fi

	# now fire the post cmdline event which is the last one
	# for the pre and post cmdline events, the bgBASH_COMMAND is the entire bgBASH_COMMAND_LINE
	bgBASH_COMMAND="$bgBASH_COMMAND_LINE"
	_fireCallbackList cmdlineHook_postCmdlineCallbackList PROMPT_COMMAND

	# reset our bgBASH_COMMAND_* vars before the next cmd starts
	bgBASH_COMMAND_LINE=""
	bgBASH_COMMAND_INDEX=0

	# if this feature is still turned on,
	# enable the DEBUG trap handler so that the next time the user enters enter, it will run before
	# the next simple cmd.
	if [ "$bgBashCmdHookFeature" ]; then
		builtin trap 'cmdlineHook_debugTrap' DEBUG
	fi
}
export -f cmdlineHook_promtCmdHook










# usage: onBeforeCmdline
# This callback is called after the user presses enter and beofre any simple cmd is ran.
# bgBASH_COMMAND is set to the entire cmdline that the user entered
function onBeforeCmdline()
{
	# its convenient to write a blank line to bgtrace before each compound command
	_bgtrace
	([[ "$cmdlineHook_traceingOn" =~ b4Cmdline ]]) && _bgtrace " b4Cmdline        : '$bgBASH_COMMAND_LINE'"

	# bgtrace win: feature
	# check to see if the user set bgTracingOn directly to 'newWin' and replace it with the next win?
	# use [[ ]] inside () so it does not overwrite the user's BASH_REMATCH
	( [[ "$bgTracingOn" =~ ^(on:)?(winNew)$ ]] ) && {
		_traceCntr openWin "${bgTracingOn#on:}"
		[[ "$bgTracingOn" =~ ^(on:)?(winNew)$ ]] && {
			echo "failed to create a new bgtrace window. turning off"
			declare -gx bgTracingOn=""
		}
	}

	# bgtrace win: feature
	# check to see if a bgtrace viewer that we are using has closed
	# use [[ ]] inside () so it does not overwrite the user's BASH_REMATCH
	if ( [[ "$bgTracingOn" =~ (^|:)win[0-9]?$ ]] ); then
		local winName="${bgTracingOn#on:}"; [ "$winName" == "win" ] && winName="out"
		[ ! -e "/tmp/bgtrace.${winName}.cntr" ] && _traceCntr openWin "${bgTracingOn#on:}"
	fi


	# import library refresh feature
	# if bg_core.sh is sourced into the environment, check to see if any of the libraries are newer
	[ "$(type -t importCntr)" ] && importCntr reloadAll -v


	return 0
}
export -f onBeforeCmdline
cmdlineHook_preCmdlineCallbackList+="    onBeforeCmdline "

# usage: onBeforeSimpleCmd
# This callback is executed right before each individual simple command that make up the entered cmd line
# If the user entered a compound command this will be invokes multiple times for the one entered cmd line
# bgBASH_COMMAND is set to simple cmd that is about to run.
# Example:
#    $ echo "hello"; echo "world"<enter>
#      1) onBeforeSimpleCmd     # bgBASH_COMMAND == 'echo "hello"'
#      2) echo "hello"
#      3) onBeforeSimpleCmd     # bgBASH_COMMAND == 'echo "world"'
#      4) echo "world"
#      5) onAfterBashCmd      # bgBASH_COMMAND == 'echo "hello"; echo "world"'
# Use "$bgBASH_COMMAND" instead of $BASH_COMMAND since $BASH_COMMAND will behave differently based on whether this
# is called from the trap or the PROMPT_COMMAND
function onBeforeSimpleCmd()
{
	([[ "$cmdlineHook_traceingOn" =~ b4SimpleCmd ]]) && _bgtrace "    b4SimpleCmd   :    '$bgBASH_COMMAND'"

	return 0
}
export -f onBeforeSimpleCmd
cmdlineHook_preSimpleCmdCallbackList+="  onBeforeSimpleCmd "


# usage: onAfterSimpleCmd
# This callback is executed after each simple command that make up the entered cmd line is finished running
# If the user entered a compound command this will be invokes multiple times for the one entered cmd line
# bgBASH_COMMAND is set to simple cmd that just finished running.
function onAfterSimpleCmd()
{
	([[ "$cmdlineHook_traceingOn" =~ afterSimpleCmd ]]) && _bgtrace "    afterSimpleCmd:    '$bgBASH_COMMAND' exit='$bgBASH_COMMAND_exitCode'"

	# for interactive use, save BASH_REMATCH into rematch
	( [[ "$bgBASH_COMMAND" =~ ^'[[' ]] ) && declare -ga rematch=("${BASH_REMATCH[@]}")
	return 0
}
export -f onAfterSimpleCmd
cmdlineHook_postSimpleCmdCallbackList+=" onAfterSimpleCmd "


# usage: onAfterCmdline
# This callback is executed after all the simple commands that make up the entered cmd line are
# finished, right before bash displays the prompt for the next cmd line
# bgBASH_COMMAND is set to the entire cmdline that the user entered
function onAfterCmdline()
{
	([[ "$cmdlineHook_traceingOn" =~ afterCmdline ]]) && _bgtrace " afterCmdline     : '$bgBASH_COMMAND'"
	return 0
}
export -f onAfterCmdline
cmdlineHook_postCmdlineCallbackList+="   onAfterCmdline "


export cmdlineHook_preCmdlineCallbackList
export cmdlineHook_preSimpleCmdCallbackList
export cmdlineHook_postSimpleCmdCallbackList
export cmdlineHook_postCmdlineCallbackList




#################################################################################################################################
# Helper Library functions

# usage: _fireCallbackList <callbackListVar> [<p1> .. <pN>]
# executes each function name in the list. Only the first occurrence of each name is executed. On return
# the <callbackListVar> will be normallized to remove dupes and any function name that returned non zero
# will be removed from the list so that it won't run next time.
# Params:
#    <callbackListVar> : is a whitespace separated list of function names that should be invoked.
#            order is significant. dupes only called the first time.
function _fireCallbackList()
{
	local callbackListVar="$1"

	# do the firing
	local -A callbackDedupe
	local callback normalizedList
	for callback in ${!callbackListVar}; do
#printf "   $((_dbgSeq++)) CB: %s\n" "$callback $*" >> $(_bgtrace --getDestination).dbgTrace

		((callbackDedupe[$callback]++ > 0)) && continue
		$callback "$@" && normalizedList+="$callback " || echo "'$callback' hook will not be called again because it exitted non zero" >&2
	done
	printf -v "$callbackListVar"  "%s" "$normalizedList"
}
export -f _fireCallbackList

# usage: assertBgDebugEnvironmentIsActive
# Some features of this script can be executed as an external script and some require the script to
# be sourced into the user's interactive base environment.  Any feature that requires that calls this
# to assert that its true or show the user a message explaining what they must do to use the feature.
function assertBgDebugEnvironmentIsActive()
{
	if [ "$bgDebugCntrRunMode" == ""extScript"" ]; then
		cat <<-EOS

		    You are invoking a development time debugging feature of $(basename $0). You must enable a terminal
		    to use these features by sourcing $(basename $0) into its interactive bash environment.
		    These features may be prohibitted in production environments.
		    Run the following command and then rerun this command.

		        source $(basename $0)

		EOS
		exit
	fi
}
export -f assertBgDebugEnvironmentIsActive

# usage: _assertError
# This is a simple version of assertError since the full version is not available.
# its critical that it only calls exit when its running in an external command so that it does not
# close the user's terminal window
function _assertError()
{
	echo "error: $@" >&2
	if [ "$bgDebugCntrRunMode" == ""extScript"" ]; then
		exit 2
	else
		# issue a cntr-c so that bash will not execute the remainder of any functions on the stack and
		# return to the prompt
		kill -SIGINT $$
		echo "system error: should not have gotten here. 'kill -SIGINT $$' did not work to end the function"
	fi
}
export -f _assertError


# usage: _bgtrace
# This is a simple version of bgtrace since the full version is not usually available in this library.
function _bgtrace()
{
	if [ "$bgTracingOn" ]; then
		local _bgtraceFile="/dev/null"
		if ([[ "$bgTracingOn" =~ (^|:)win[0-9]$ ]]); then
			local win=${bgTracingOn#*:}
			_bgtraceFile="/tmp/bgtrace.$win"
		elif ([[ "$bgTracingOn" =~ (on:)?win$ ]]); then
			_bgtraceFile="/tmp/bgtrace.out"
		elif ([[ "$bgTracingOn" =~ : ]]); then
			_bgtraceFile=${bgTracingOn#*:}
			_bgtraceFile=${_bgtraceFile:-/tmp/bgtrace.out}
		else
			_bgtraceFile="/dev/stderr"
		fi

		[ "$1" != "--getDestination" ] && echo "$@" >>$_bgtraceFile
	fi

	[ "$1" == "--getDestination" ] && echo "${_bgtraceFile:-/dev/null}"
}
export -f _bgtrace


# usage: __bgCheckForMissingDeps <dependencies>
# used by vinstall to warn the user if there should be dependencies installed for the packages being
# virtually installed
function __bgCheckForMissingDeps()
{
	(
		bgTracingBanner=""
		source /usr/lib/bg_core.sh --minimal

		local deps="$(echo "$*" | sed -e 's/[ \t\n][ \t\n]*/\n/g' | sort | uniq)"
		local depsNeedingInstall=""
		local depsWithProblems=""
		local dep
		for dep in $deps; do
			local status=""
			echo "$bgInstalledPkgNames" | grep -q "\<$dep\>" && status="Status: install ok "
			[ ! "$status" ] && status="$(dpkg -s  "$dep"  2>/dev/null | grep "^Status:")"
			if [[ "$status" =~ ^installed$ ]]; then
				depsWithProblems="$depsWithProblems${depsWithProblems:+ }$dep"
			elif [[ ! "$status" =~ ^Status:\ install\ ok\  ]]; then
				depsNeedingInstall="$depsNeedingInstall${depsNeedingInstall:+ }$dep"
			fi
			shift
		done
		if [ "$depsWithProblems" ]; then
			echo "warning: these packages are required by some vinstalled commands but might not be installed correctly.\n\t'$depsWithProblems'"
		fi
		if [ "$depsNeedingInstall" ]; then
			echo "warning: these packages are required by some vinstalled commands but are not installed '$depsNeedingInstall'"
			echo "   run: 'sudo apt-get install $depsNeedingInstall' if you think you will need these."
		fi
	)
}
export -f __bgCheckForMissingDeps




#################################################################################################################################
# Script Global Code
# Above this point this script should be only function definitions. Below is global code that will be executed
# when the external script is ran or sourced.

# This is the init code for when the script is sourcing into the environment or being reloaded
if [ "$bgDebugCntrRunMode" != "extScript" ]; then

	# this is used in the cuiWinID of debug windows. The idea is that you can use it like $$ in scripts
	# to make sure a name is unque to a proc but it is stable for any proc ran in a particular term window.
	declare -gx bgTermID=$$

	# domData / awkData / plugins integration.
	if [ "$bgVinstalledSandbox" ] && [ -d "$bgVinstalledSandbox/.bglocal" ]; then
		declare -gx vinstallMeScopeFolder="$bgVinstalledSandbox/.bglocal/vinstall"
		mkdir -p "$vinstallMeScopeFolder"
	fi

	# banner is on by default
	export bgTracingBanner="on"

	# install the pre and post interactive command hooks by default.
	# See 'bg-debugCntr debugger bashCmdHooks on|off|status'
	_bashComandHooks on
fi


# We get to this point whenever the external script file is executed or sourced. In either case, the function
# by the same name should exist at this point so we can pass off the work to it.
# (either in the interactive bash environment or in the external cmd's execution child environment)
# The only caveat is that if there was a script error and the function did not get defined for any reason,
# we don't want to invoke that name because it would infinitely invoke the same external command and come back here.
if [ "$(type -t "$(basename $BASH_SOURCE)")" == "function" ]; then
	[ "$1" != "noop" ] && $(basename $BASH_SOURCE) "$@"
else
	_assertError "function '$(basename $BASH_SOURCE)' not defined"
fi



# bgDebugCntrRunMode will only be defined while this global script code is running. When sourced functions
# run normally it will not be defined
unset bgDebugCntrRunMode
