#!/usr/bin/env bash

###############################################################################
# Includes and defines

projectName=bg-dev

source /usr/lib/bg_core.sh
import bg_ini.sh ;$L1;$L2
import bg_dev.sh ;$L1;$L2
import bg_manifest.sh ;$L1;$L2
import bg_install.sh ;$L1;$L2
import bg_funcman.sh ;$L1;$L2
import bg_unitTestRunner.sh ;$L1;$L2

# TODO: decide if manifest should be moved under install now. We need to keep the top level uncluttered b/c there will be more stuff.
#       and arguably, the manifest concept is linked to install. On the other hand, seeing what is in the project is not related to
#       install. the default 'show' command can serve that purpose though.
supportedCmds="manifest install uninstall funcman tests"

###############################################################################
# Command manpage
# usage: bg-dev [-q|-v] manifest|install|uninstall|funcman|tests [<subCmdOptions>] [<subCmdArguments>]
# a tool to manage software projects created in the style of bg-core.
# This command is organized into sub commands. Some sub commands have their own manpage named bg-dev-<subcommand>.
#
# A project is a folder that uses git for verion control and sharing. It can be installed directly from its project folder and
# also be built into a deb or rpm package for distribution and installation via package managers.
#
# A project contains zero or more assets of various types. It is those assets that get installed into a host.
#
# Sub Commands:
#  * manifest : A project's manifest is a text file that lists each installable asset contained in the project
#  * install  : Copy the a project's assets into a destination file system structure
#  * uninstall: remove a project's assets from a destination file system structure
#  * funcman  : scans the project's source to generate documentation and a ctags file.
#  * tests    : run and manage a project's tests
#
# Builtin Asset Types:
# These are the asset types that are supported natively by this command without requiring a plugin from another package.
#  * AwkLib      : (*.awk) an awk language script. awk is the gnu text processing tool.
#  * BashLib     : (*.sh) a bash language library script mean to be imported (aka sourced) by bash scripts
#  * Cmd         : (root folder) an executable file. It can be binary or script. Scripts require #!<processor> first line.
#  * Cron        : (cron.d/*) a cron configuration file
#  * Data        : (data/*) any files in any foder structure. Will be installed on host and avaialble in scripts at $pkgDataFolder/...
#  * Doc         : (doc/*) any files meant to document the project. Includes changelog and copyright
#  * Etc         : (etc/*) initial config files to be installed on the target host.
#  * GlobalBashCompletion : bash_completion scripts that will be loaded at every user's bash shell startup.
#  * Manpage     : (man<n>/*) manpages. Note that funcman generates man pages from source that will be automatically add to the
#                  manifest but you can add manually created pages too in the man<n>/ folders. <n> is the section number
#  * Opt         : (opt/) arbitrary files put in the /opt hierarchy.
#  * SysDInit    : (systemd/*) init scripts for systemd daemons and event handlers
#  * Syslog      : (rsyslog.d/) syslog configuration
#  * SysVInit    : (init.d/) old style init scipts for daemons
#  * UnitTest    : (unitTests) Tests are not installed but are available for tools to use
#
# See Also:
#    man(1) bg-dev-manifest
#    man(1) bg-dev-install
#    man(1) bg-dev-funcman
#    man(1) bg-dev-tests

###############################################################################
# Functions

# this is invoked by oob_invokeOutOfBandSystem when -hb is the first param
# The bash completion script calls this get the list of possible words.
function oob_printBashCompletion()
{
	bgBCParse "<glean>" "$@"; set -- "${posWords[@]:1}"

	cmd="${posWords[1]}"

	case $cmd:$posCwords in
		*:1) echo $supportedCmds ;;
		install:2|uninstall:2)
			[ ! "$cur" ] && echo "<options_available>"
			[[ "$cur" =~ ^--pkg= ]] && echo "\$(cur:${cur#--pkg=}) deb rpm"
			[[ "$cur" =~ ^- ]] && [[ ! "$cur" =~ ^--pkg= ]] && echo "--pkg=%3A "
			;;

		manifest:2) echo "print update summary listAssetTypes" ;;

		funcman:2)  echo "update test listTemplates" ;;
		funcman:*)
			case $2:$((posCwords-2)) in
				update:*) completeFromSyntaxString "[--compare] [--dry-run]" 1 "$cur" ;;
				test:*)  echo "\$(doFilesAndDirs) -q -v";;
			esac
			;;

		tests:2) echo "list run report show" ;;
		tests:*)
			case $2 in
				list)    completeFromSyntaxString "[-f|--fullyQualyfied]" 1 "$cur"; completeUtIDSpec "$cur" ;;
				run)     completeUtIDSpec "$cur" ;;
				report)  completeUtIDSpec "$cur" ;;
				show)    completeUtIDSpec "$cur" ;;
			esac
			;;
	esac
	exit
}

# Use this function to provide BC suggestions for positional parameters
# see man bg-overviewOutOfBandScriptFunctions for details
function oob_helpMode()
{
	local words cword cur prev optWords posWords posCwords
	parseForBashCompletion --compat2 words cword cur prev optWords posWords posCwords "$@"

	local cmd="${posWords[1]}"
	case ${cmd:-main} in
		main)  man "$(basename $0)" ;;
		*)     man "$(basename $0)" ;;
	esac
}


###############################################################################
# Command manpage: bg-dev-manifest
# usage: bg-dev manifest print|update|summary|listAssetTypes [-v|-q]
# operations on a project's manifest file.
# A project's manifest is a text file that lists each installable asset contained in the project.
# The manifest file is built just before installation and used by the installer to know what needs to be done.
# The manifest typically resides in .bglocal/ so that it is not committed to the project's repository.
#
# To build the manifest the builtin builder scans the project folder for any builtin asset type and then
# invokes any available asset types plugins to recognize and include assets of their type. It should be very
# fast to build the manfest and it can be updated frequently by tools in the developer environment.
#
# Update Sub Command:
# Update builds a new manifest file in a temporary location and then only replaces the contents of .bglocal/manifest if it has
# changed so that the timestamp of that file reflects when assets are added or removed.
#
# Print Sub Command:
# Print builds a new manifest and prints it to stdout without saving it to any file.
#
# Summary Sub Command:
# Prints to stdout how many assets of each type are contained in the project.
#
# ListAssetTypes Sub Command:
# Print each of the asset types known to the system t this time. Installing other packages can add additional asset types.
#
# Plugins:
# To support a new type of project asset, a helper command can be added that scans the project source folder and returns matching
# files or folders of that asset type. Any command that starts with bg-dev-findAsset* or bash function starting with findAsset*
# will be invoked during the manifest file build. If the command finds any assets it should write them to stdout in the line format
# of the manifest file.
#
# These findAsset plugin commands are invoked with the CWD/PWD set to the project's root folder. $pkgName is set to the project's
# package name.
#
# Typicaly an asset type plugin would be provided in a package project and when installed provides an bg-dev-findAsset<assetType>
# command and a bg-dev-install<assetType> command (see bg-dev-install). Alternatively, it can provide a single script plugin file
# that contains a findAsset<assetType> function and install<assetType> function. See man bg-plugins.
#
# If a project relies on an extended asset type provided by some other package, that package needs to be installed when the project
# is installed (or built into a package) or else that asset will not be included.
#
# File Format:
# <pkgName>           <assetType>         <file|folder>
# Each line has three columns separated by one or more spaces or tabs. Including <pkgName> makes it easy to combine manifests from
# all the packages that use them that are installed on a host.
#
# By convention to make the file friendlier to human inspection the first two columns are right padded to 20 characters each,
# however that is not necessary for proper functioning.
#
# This is a bash command that formats the line correctly.
#    printf "%-20s %-20s %s\n" "$pkgName" "<assetType>"  "<foundFileOrFolder>"
function manifest()
{
	local verbosity=${verbosity}
	while [ $# -gt 0 ]; do case $1 in
		-v|--verbose) ((verbosity++)) ;;
		--verbosity*) bgOptionGetOpt val: verbosity "$@" && shift ;;
		-q|--quiet) ((verbosity--)) ;;
		*)  bgOptionsEndLoop "$@" && break; set -- "${bgOptionsExpandedOpts[@]}"; esac; shift;
	done

	local mode="$1"; shift

	case ${mode:-print} in
		print)   manifestBuild "$@" ;;
		update)  manifestUpdate "$@" ;;
		summary) manifestSummary "$@" ;;
		listAssetTypes) manifestListKnownAssetTypes "$@" ;;
	esac
}


# Command manpage: bg-dev-install
# usage: bg-dev install [-v|-q] [--pkg=deb|rpm]
# usage: bg-dev uninstall [-v|-q] [--pkg=deb|rpm]
# copies the installable assets contained in a project into a destination file system tree.
# This install action is lower level than package manager installs. This is similar to the 'install' target in a project's makefile.
# When building a package for deb or rpm, this is used to create the staging file system tree that will go into the package file.
# A developer can also use this to install a project onto a host directly from its source folder for testing or for personal
# projects that are not meant for distribution.
#
# The default destination is the root filesystem of the host where it is running. The user will typically be prompted for their
# sudo password in that case. An uninstall script will be left in /var/lib/bg-core/<pkgName>/uninstall.sh. When invoked, it will
# undo all the actions done by install.
#
# The --pkg=<pkgType> option changes the destination file system tree to the project's .bglocal/pkgStaging-<pkgType> folder. .bglocal
# is a project subfolder that is ignored by get so development tools can use it as a project local temp folder.
#
# The <pkgType> may affect the structure of the destination filesystem as well its root path. When installing to the host filesystem,
# the <pkgType> is gleaned from the environment. The initial algorithm 1) if 'apt' is avaliable use 'deb' 2) if 'rpm' is available
# use 'rpm' 3) by default use 'deb'. The notion is that any OS distribution that supports apt will have a filesystem structure that
# complies with the debian package standard and likewise supporting rpm implies support for the Red Hat standard.
#
# Implementation:
# This function uses the manifest sub command to make sure that the project's manifest is up to date and then iterates over each
# asset type present in the manifest and calls a helper command based on the asset type and <pkgType>.
#
# Helper Commands:
# The helper commands follow a naming convention that allows common implementations across <pkgTypes> where appropriate and specific
# implementations when needed.
# These command names are tried, in order, until one is found.
#     bg-dev-install${assetType^}_${pkgType}   e.g. bg-dev-installBashCmd_deb
#     install${assetType^}_${pkgType}          e.g. installBashCmd_deb
#     bg-dev-install${assetType^}              e.g. bg-dev-installBashCmd
#     install${assetType^}                     e.g. installBashCmd
# The bg-dev-install* names would typically match external commands installed by some package and the install* names would typically
# match a builtin function or a function provided by a bgplugin
#
# Helper Runtime Environment:
# This is the environment that this function provides for helper functions that it invokes
#    working directory: the CWD/PWD is the root of the project's source folder. The DESTDIR may be relative to this so if you change
#                directory in your helper command, you need to take that into account
#    $1,$2,..$N : the files or folders of this asset type that are present in the project. The paths are relative to the project
#                 root
#    DESTDIR    : The root of the filesystem being installed to. If its empty, the installation goes to the real system folders on
#                 the host. The --pkg option changes it to the staging directory inside the package source folder
#    PRECMD     : This is typically either "" or "sudo " depending on whether the current user has access to write to DESTDIR
#                 helper functions should prefix comands that modify the DESTDIR filesystem with it like '$PRECMD cp $file $DESTDIR/...'
#                 This convention supports code that can install to the system folders using sudo or the pkgStaging folder without.
#    pkgName    : the name of the package being installed
#    UNINSTSCRIPT : path to the uninstall script that the helper should append to. Each action that the installer does to the DESTDIR
#                 should be represented by a command appended to this script that undoes that action. The uninstall script is typically
#                 not used by package managers but is used when installing/uninstalling to/from a host directly from the project
#                 folder.
#    HOSTMANIFEST : path to the host manifest file that is built during installation. Its similar to the package manifest but the
#                 files in the third column have the absolute path on the host instead of the relative path in the project folder.
#    manifestProjPath : contains the relative path from the project root of the manifest file. This is typicall not needed because
#                 the entries from this file that match the asset type are passed to the command as cmdline arguments.
#
# Uninstall:
# The companion subcommand 'uninstall' invokes the script created by the install subcommand. This can be useful if you install a
# project onto a host for testing and then want to remove it. You can give uninstall the same --pkg option that install takes to
# make it operate on the package staging folder but aside from testing to see if the uninstall script works, that is not very useful.
#
# Since uninstall only invokes the uninstall script left behind by the last install, it will remove correctly remove assets from the
# last installed version even when they no longer exist in the current project version being installed.
#
# The install subcommand will automatically invoke an uninstall script found in the DESTDIR to clean up DESTDIR before the new version
# is installed. This ensures that if you remove an asset, when you re-install the project, that asset will be removed from the DESTDIR
function install()
{
	bgInstall "$@"
}

function uninstall()
{
	bgUninstall "$@"
}














# Command manpage: bg-dev-funcman
# usage: bg-dev funcman update [-v|-q] [--dry-run] [--compare] [-t|--templateFolder=<path>] [-o|--outputFolder=<path>]
# usage: bg-dev funcman test [-v|-q] <sourceFile>
# The name comes from shortening "function manpage". Now it creates other types of manpages from the source files as well as those
# for functions.
#
# Each bashLib in the project will have a man7 page generated and each bashCmd will have a man1 page. bashLib files will also
# produce a man3 page for any function that does not start with a '_' (a leading underscore indicates a private function)
#
# For any of these automatically generated manpages, the script author can provide additional content for that page in a comment
# block. For the bashCmd or bashLib page, the comment block is any contiguous block of un-indented comments that start with
# "# Command" or "# Library". For function manpages its the block of comments that immediately precede the function declaration
# and any alias function declarations.
#
# The code author can embed additional man pages by including a comment block starting with
# "# man(<n>.<type>) <pageName>" where <n>.<type> refers to a template named funcman.<n>.<type> in a profile folder or this project's
# data folder.
#
# Formatting:
#    See man(5) funcman -- documents the comment syntax supportted to create manpages
#
# Update Sub Command:
# The update sub command updates the generated manpages for the project that the command is running in. It will only update the
# timestamp on manpage files whose content has changed. Generated manpages reside in the .bglocal/funcman/ sub folder in the project
# It generates the current manpage content in a temporary folder. Then it compares those files with the ones in .bglocal/funcman.
# If neither the --dry-run or --compare options are specified it will go on to make the changes in .bglocal/funcman needed to make
# it be identical to the temporary folder. If --dry-run is specified, it will stop and print out the name of the temporary folder so
# that the user can inspect the contents. If --compare is specified, it will stop and open the two folders in the compare application
# registered for the user. See man(3) getUserCmpApp
# Update invokes the funcman_runBatch library function to do its work. See man(3) funcman_runBatch
#
# Test Sub Command:
# The test subcommand runs the funcman scanner a source file without generating the manpages but printing diagnostic information
# to stdout. This is typically used to confirm that the scanner is interpretting the source correctly to create the intended manpages.
# Add -v (verbsose) options to increase the printed diagnostics and -q (quiet) options to decrease it.
#
# ListTemplates Sub Command:
# Prints the names of the known funcman templates
#
# See Also:
#    man(7) bg_funcman.sh
#    man(3) getUserCmpApp
#    man(3) funcman_runBatch
#    man(3) funcman_testRun
function funcman() {
	local cmd="${1:-update}"; shift
	case ${cmd} in
		update)       funcman_runBatch       "$@" ;;
		test)		  funcman_testRun        "$@" ;;
		listTemplates) funcman_listTemplates "$@" ;;
		*) assertError -v cmd "unknown cmd" ;;
	esac
}


# Command manpage: bg-dev-tests
# usage: bg-dev tests list   [-f|--fullyQualyfied] [all]
#        bg-dev tests list   [-f|--fullyQualyfied] <utIDSpec> [...<utIDSpecN>]
# usage: bg-dev tests run    [-v|--verbose] [all]
#        bg-dev tests run    [-v|--verbose] <utIDSpec> [...<utIDSpecN>]
# usage: bg-dev tests report [-v|--verbose] [all]
#        bg-dev tests report [-v|--verbose] <utIDSpec> [...<utIDSpecN>]
# usage: bg-dev tests show   [-v|--verbose] [all]
#        bg-dev tests show   [-v|--verbose] <utIDSpec> [...<utIDSpecN>]
# This is the front end to the unit test framework for bg-core style pacakges. The terms unittest and testcase are used interchangably
# but in the future when different kinds of tests are possible we will have to be more precise.
#
# Testcases are identified by their utID. When a testcase is ran, it produces output to stdout that captures the entire state of its
# run. For example if it produces stderr output, that output is merged with stdout prefixed to indicate that it came from stderr.
# If a command exists with a non-zero exit code, a msg to that effect will be written to stdout.
#
# The testcase is considered to have passed if the output it produces is logically equivalant to the expected output that is committed
# to the project's repo. That saved, expected output is called the 'plato' output as a nod to the philosopher's ideas. Lines that
# start with # or // are not considered part of the logical output. Those lines can be useful to humans understanding the output.
#
# There are two steps to controlling the behavior of a package through its testcases. First is editting the plato data to ensure
# that it represents the desired functionality. Second is developing the source code so that the code that is the target of a test
# produces that output. In practice, a test case author typically writes a new test, observeres the output and if it produces the
# output that is considered correct, copies that actaul output to the plato data.
#
# After the initall plato data is set, from that point on, the testcase will monitor if anything changes the expected output. If
# so, the testcase fails and someone decides if the code needs to change to keep the expected behaior the same, or if the plato
# data should change to document that the expected behavior is now different.  The git history of the plato data is the history of
# how the project's behavior (which could be an API) has evolved over time.
#
# A good testcase will output to un-commented lines, only information that is relavent to the target of the test functioning as required
# deviod of arbitrary information that would not affect whether the target is working correctly. That way the testcase will only
# break when a significant change in behavior happens.
#
# run sub command:
# exectues the specified testcases, updates the saved data and reportes on the outcome. Run reports on two things. First is whether
# each testcase produced new, updated, or unchanged output relative to the last time it was ran. Second is whether each test case
# passed, failed, had a setup error, or is missing plato data which means that it is uninitialized.
#
# list sub command:
# prints the utID for each testcase that matches the <utIDSpec> specified.
#
# report sub command:
# produces similar output as the run command by using the previous run data instead of runing the testcases. The modification
# information is supressed since it is all unchanged.
#
# See Also:
#    man(1) bg-unitTests.ut
function testsCntr()
{
	local cmd="${1:-list}"; shift
	case ${cmd} in
		list)       utfList       "$@" ;;
		run)		utfRun        "$@" ;;
		report)     utfReport     "$@" ;;
		show)       utfShow       "$@" ;;
		parse)      utfIDParse -t "$@" ;;
		*) assertError -v cmd "unknown cmd" ;;
	esac
}


###############################################################################
# Main script

# default values for parameters
command=""
verbosity=1
oob_invokeOutOfBandSystem "$@"
while [ $# -gt 0 ]; do case $1 in
	-v|--verbose) ((verbosity++)) ;;
	-q|--quiet) ((verbosity--)) ;;
	--verbosity*) bgOptionGetOpt val: verbosity "$@" && shift ;;
	*)  bgOptionsEndLoop "$@" && break; set -- "${bgOptionsExpandedOpts[@]}"; esac; shift;
done
command="$1"; shift

baseDir="$(pwd)"

[ ! -f .bg-sp/config ] && assertError "This does not appear to be a bg-dev project folder because there is no .bg-sp/config file"

pkgName="$(iniParamGet ".bg-sp/config" . packageName)"
assertNotEmpty pkgName ".bg-sp/config does not contain a packageName=<name> setting"

[ -f "${baseDir}/.bg-sp/config" ] || assertError "This '$pkgName' folder does not appear to be a bgproject folder"


case ${command:-show} in
	manifest)      manifest   "${passThruOpts[@]}" "$@" ;;
	install)       install    "${passThruOpts[@]}" "$@" ;;
	uninstall)     uninstall  "${passThruOpts[@]}" "$@" ;;
	funcman)       funcman    "${passThruOpts[@]}" "$@" ;;
	tests)         testsCntr  "${passThruOpts[@]}" "$@" ;;
	show)          manifest summary  ;;
	*)  echo "error: unknown command '$command'. "
		echo "   See man $(basename $0)"
		;;
esac
