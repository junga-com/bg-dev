#!/usr/bin/env bash

###############################################################################
# Includes and defines

projectName=bg-dev

source /usr/lib/bg_core.sh
import bg_ini.sh ;$L1;$L2
import bg_dev.sh ;$L1;$L2
import bg_funcman.sh ;$L1;$L2
import bg_unitTestRunner.sh ;$L1;$L2

# TODO: decide if manifest should be moved under install now. We need to keep the top level uncluttered b/c there will be more stuff.
#       and arguably, the manifest concept is linked to install. On the other hand, seeing what is in the project is not related to
#       install. the default 'show' command can serve that purpose though.
supportedCmds="manifest install uninstall funcman tests"

###############################################################################
# Command manpage
# usage: bg-dev [-q|-v] manifest|install|uninstall|funcman|tests [<subCmdOptions>] [<subCmdArguments>]
# a tool to manage software projects created in the style of bg-core.
# This command is organized into sub commands. Some sub commands have their own manpage named bg-dev-<subcommand>.
#
# A project is a folder that uses git for verion control and sharing. It can be installed directly from its project folder and
# also be built into a deb or rpm package for distribution and installation via package managers.
#
# A project contains zero or more assets of various types. It is those assets that get installed into a host.
#
# Sub Commands:
#  * manifest : A project's manifest is a text file that lists each installable asset contained in the project
#  * install  : Copy the a project's assets into a destination file system structure
#  * uninstall: remove a project's assets from a destination file system structure
#  * funcman  : scans the project's source to generate documentation and a ctags file.
#  * tests    : run and manage a project's tests
#
# Builtin Asset Types:
# These are the asset types that are supported natively by this command without requiring a plugin from another package.
#  * AwkLib      : (*.awk) an awk language script. awk is the gnu text processing tool.
#  * BashLib     : (*.sh) a bash language library script mean to be imported (aka sourced) by bash scripts
#  * Cmd         : (root folder) an executable file. It can be binary or script. Scripts require #!<processor> first line.
#  * Cron        : (cron.d/*) a cron configuration file
#  * Data        : (data/*) any files in any foder structure. Will be installed on host and avaialble in scripts at $pkgDataFolder/...
#  * Doc         : (doc/*) any files meant to document the project. Includes changelog and copyright
#  * Etc         : (etc/*) initial config files to be installed on the target host.
#  * GlobalBashCompletion : bash_completion scripts that will be loaded at every user's bash shell startup.
#  * Manpage     : (man<n>/*) manpages. Note that funcman generates man pages from source that will be automatically add to the
#                  manifest but you can add manually created pages too in the man<n>/ folders. <n> is the section number
#  * Opt         : (opt/) arbitrary files put in the /opt hierarchy.
#  * SysDInit    : (systemd/*) init scripts for systemd daemons and event handlers
#  * Syslog      : (rsyslog.d/) syslog configuration
#  * SysVInit    : (init.d/) old style init scipts for daemons
#  * UnitTest    : (unitTests) Tests are not installed but are available for tools to use
#
# See Also:
#    man(1) bg-dev-manifest
#    man(1) bg-dev-install
#    man(1) bg-dev-funcman
#    man(1) bg-dev-tests

###############################################################################
# Functions

# this is invoked by oob_invokeOutOfBandSystem when -hb is the first param
# The bash completion script calls this get the list of possible words.
function oob_printBashCompletion()
{
	bgBCParse "<glean>" "$@"; set -- "${posWords[@]:1}"

	cmd="${posWords[1]}"

	case $cmd:$posCwords in
		*:1) echo $supportedCmds ;;
		install:2|uninstall:2)
			[ ! "$cur" ] && echo "<options_available>"
			[[ "$cur" =~ ^--pkg= ]] && echo "\$(cur:${cur#--pkg=}) deb rpm"
			[[ "$cur" =~ ^- ]] && [[ ! "$cur" =~ ^--pkg= ]] && echo "--pkg=%3A "
			;;

		manifest:2) echo "print update summary listAssetTypes" ;;

		funcman:2)  echo "update test listTemplates" ;;
		funcman:*)
			case $2:$((posCwords-2)) in
				update:*) completeFromSyntaxString "[--compare] [--dry-run]" 1 "$cur" ;;
				test:*)  echo "\$(doFilesAndDirs) -q -v";;
			esac
			;;

		tests:2) echo "list run report show" ;;
		tests:*)
			case $2 in
				list)    completeFromSyntaxString "[-f|--fullyQualyfied]" 1 "$cur"; completeUtIDSpec "$cur" ;;
				run)     completeUtIDSpec "$cur" ;;
				report)  completeUtIDSpec "$cur" ;;
				show)    completeUtIDSpec "$cur" ;;
			esac
			;;
	esac
	exit
}

# Use this function to provide BC suggestions for positional parameters
# see man bg-overviewOutOfBandScriptFunctions for details
function oob_helpMode()
{
	local words cword cur prev optWords posWords posCwords
	parseForBashCompletion --compat2 words cword cur prev optWords posWords posCwords "$@"

	local cmd="${posWords[1]}"
	case ${cmd:-main} in
		main)  man "$(basename $0)" ;;
		*)     man "$(basename $0)" ;;
	esac
}


###############################################################################
# Command manpage: bg-dev-manifest
# usage: bg-dev manifest print|update|summary|listAssetTypes [-v|-q]
# operations on a project's manifest file.
# A project's manifest is a text file that lists each installable asset contained in the project.
# The manifest file is built just before installation and used by the installer to know what needs to be done.
# The manifest typically resides in .bglocal/ so that it is not committed to the project's repository.
#
# To build the manifest the builtin builder scans the project folder for any builtin asset type and then
# invokes any available asset types plugins to recognize and include assets of their type. It should be very
# fast to build the manfest and it can be updated frequently by tools in the developer environment.
#
# Update Sub Command:
# Update builds a new manifest file in a temporary location and then only replaces the contents of .bglocal/manifest if it has
# changed so that the timestamp of that file reflects when assets are added or removed.
#
# Print Sub Command:
# Print builds a new manifest and prints it to stdout without saving it to any file.
#
# Summary Sub Command:
# Prints to stdout how many assets of each type are contained in the project.
#
# ListAssetTypes Sub Command:
# Print each of the asset types known to the system t this time. Installing other packages can add additional asset types.
#
# Plugins:
# To support a new type of project asset, a helper command can be added that scans the project source folder and returns matching
# files or folders of that asset type. Any command that starts with bg-dev-findAsset* or bash function starting with findAsset*
# will be invoked during the manifest file build. If the command finds any assets it should write them to stdout in the line format
# of the manifest file.
#
# These findAsset plugin commands are invoked with the CWD/PWD set to the project's root folder. $pkgName is set to the project's
# package name.
#
# Typicaly an asset type plugin would be provided in a package project and when installed provides an bg-dev-findAsset<assetType>
# command and a bg-dev-install<assetType> command (see bg-dev-install). Alternatively, it can provide a single script plugin file
# that contains a findAsset<assetType> function and install<assetType> function. See man bg-plugins.
#
# If a project relies on an extended asset type provided by some other package, that package needs to be installed when the project
# is installed (or built into a package) or else that asset will not be included.
#
# File Format:
# <pkgName>           <assetType>         <file|folder>
# Each line has three columns separated by one or more spaces or tabs. Including <pkgName> makes it easy to combine manifests from
# all the packages that use them that are installed on a host.
#
# By convention to make the file friendlier to human inspection the first two columns are right padded to 20 characters each,
# however that is not necessary for proper functioning.
#
# This is a bash command that formats the line correctly.
#    printf "%-20s %-20s %s\n" "$pkgName" "<assetType>"  "<foundFileOrFolder>"
function manifest()
{
	local verbosity=${verbosity}
	while [ $# -gt 0 ]; do case $1 in
		-v|--verbose) ((verbosity++)) ;;
		--verbosity*) bgOptionGetOpt val: verbosity "$@" && shift ;;
		-q|--quiet) ((verbosity--)) ;;
		*)  bgOptionsEndLoop "$@" && break; set -- "${bgOptionsExpandedOpts[@]}"; esac; shift;
	done

	local mode="$1"; shift

	case ${mode:-print} in
		print)   manifestBuild "$@" ;;
		update)  manifestUpdate "$@" ;;
		summary) manifestSummary "$@" ;;
		listAssetTypes) manifestListKnownAssetTypes "$@" ;;
	esac
}

# usage: manifestListKnownAssetTypes
# print a list of known asset types to stdout
function manifestListKnownAssetTypes()
{
	local assetTypeFn; for assetTypeFn in $( { compgen -c bg-dev-install; compgen -A function install; } | sort -u); do
		local assetType="${assetTypeFn#bg-dev-install}"
		assetType="${assetType#install}"
		printf "%s " "$assetType"
	done
	printf "\n"
}


function manifestSummary()
{
	manifestBuild | awk '
		{
			pkg=$1; type=$2; file=$3
			types[pkg][type]++
		}
		END {
			for (pkg in types) {
				printf("%s contains:\n", pkg)
				for (type in types[pkg]) {
					printf("   %4s %s\n", types[pkg][type], type)
				}
			}
		}
	'
}

function _findAssetsOfType()
{
	local assetType="$1"; shift
	local -A fileList=()
	fsExpandFiles -S fileList "$@"
	local filename; for filename in "${!fileList[@]}"; do
		printf "%-20s %-20s %s\n" "$pkgName" "$assetType"  "$filename"
	done
}

# usage: manifestUpdate
# This saves the results of manifestBuild in a temporary file and replaces .bglocal/manifest with it if they are not identical.
function manifestUpdate()
{
	local verbosity=${verbosity}
	while [ $# -gt 0 ]; do case $1 in
		-v|--verbose) ((verbosity++)) ;;
		-q|--quiet) ((verbosity--)) ;;
		*)  bgOptionsEndLoop "$@" && break; set -- "${bgOptionsExpandedOpts[@]}"; esac; shift;
	done

	local tmpFile="$(mktemp)"
	manifestBuild | sort > "$tmpFile"
	if [ ! -e $manifestProjPath ] || ! diff -q "$tmpFile" "$manifestProjPath" >/dev/null; then
		[ ! -e "${manifestProjPath%/*}" ] && mkdir -p "${manifestProjPath%/*}"
		cat "$tmpFile" > $manifestProjPath
		[ ${verbosity:-0} -ge 1 ] && echo "$manifestProjPath was updated"
		rm "$tmpFile"
		return 0
	fi
	[ ${verbosity:-0} -ge 1 ] && echo "$manifestProjPath is already up to date"
	rm "$tmpFile"
	return 1
}

# usage: manifestBuild
# This scans the project folder and writes to stdout a line for each found asset. Each line has <pkgName> <assetType> <fileOrFolder>
# It has builtin scanners for many common asset types and works with discoverable plugins to support new types.
function manifestBuild()
{
	local -A fileList=();

	# commands are executables without an extension in the project root folder.
	# script libraries of various types are identified by their extension and can reside in any sub folder (but typically ./lib/)

	# these are the builtin asset types
	# TODO: all these builtin asset scanners could be combined into one bgfind invocation which would be more efficient. So far its
	#       very fast even making mutiple scans but if it gets noticably slower on big projects, we could make that change.
	_findAssetsOfType "cmd"          * -perm /a+x -type f ! -name "*.*" ! -name Makefile
	_findAssetsOfType "bashLib"  -R  *  -type f   -name "*.sh"
	_findAssetsOfType "awkLib"   -R  *            -type f  -name "*.awk"
	_findAssetsOfType "unitTest" -R  unitTests/*  -type f  -perm /a+x -name "*.ut"
	_findAssetsOfType "manpage"  -R  man[1-9] .bglocal/funcman -type f  -path "*man*/*.[1-9]*"
	_findAssetsOfType "etc"      -R  etc/         -type f
	_findAssetsOfType "opt"      -R  opt/         -type f
	_findAssetsOfType "data"     -R  data/        -type f
	_findAssetsOfType "doc"      -R  readme.md README.md doc/ -type f
	_findAssetsOfType "cron"     -R  cron.d/      -type f
	_findAssetsOfType "sysVInit" -R  init.d/      -type f
	_findAssetsOfType "sysDInit" -R  systemd/     -type f
	_findAssetsOfType "syslog"   -R  rsyslog.d/   -type f
	_findAssetsOfType "globalBashCompletion" -R  * -name "*.globalBashCompletion" -type f

	# export things for helper plugins to use
	export pkgName

	# now invoke any plugins available
	local findAssetCmd; for findAssetCmd in $({ compgen -c bg-dev-findAsset; compgen -A function findAsset; } | sort -u); do
		$findAssetCmd
	done
}

### define the built-in helper functions for all the known asset types. Each of these are discovered by the builtin section of the
# manifestBuild function
# note that an install* function does not have to use _installFilesToDst. It can do anything it wants to represent its assets in
# the destination file system. See man(1) bg-dev-install and the _installFilesToDst function as a model to build a custom helper.
function installUnitTest()   { : ; } # unittests are not installed
#                                                                    <type>      <pkgPath>      <dstPath>
function installCmd()        { _installFilesToDst --flat             "cmd"       ""             "/usr/bin"; }
function installBashLib()    { _installFilesToDst --flat             "bashLib"   ""             "/usr/lib"; }
function installAwkLib()     { _installFilesToDst --flat             "awkLib"    ""             "/usr/share/awk"; }
function installEtc()        { _installFilesToDst                    "etc"       "etc/"         "/etc"; }
function installOpt()        { _installFilesToDst                    "opt"       "opt/"         "/opt"; }
function installData()       { _installFilesToDst                    "data"      "data/"        "/usr/share/$pkgName"; }
function installDoc()        { _installFilesToDst -z "doc/changelog" "doc"       "doc/"         "/usr/share/$pkgName"; }
function installManpage()    { _installFilesToDst -z "^"             "manpage"   ".bglocal/funcman" "/usr/share/man"; }
function installCron()       { _installFilesToDst                    "cron"      "cron.d/"      "/etc/cron.d"; }
function installSysVInit()   { _installFilesToDst                    "sysVInit"  "init.d/"      "/etc/init.d"; }
function installSysDInit()   { _installFilesToDst                    "sysDInit"  "systemd/"     "/etc/systemd/system"; }
function installSyslog()     { _installFilesToDst                    "syslog"    "rsyslog.d/"   "/etc/rsyslog.d"; }
function installGlobalBashCompletion() { _installFilesToDst --flat   "globalBashCompletion" ""  "/etc/bash_completion.d"; }

# usage: _installFilesToDst <type> <pkgPath> <dstPath> [<file1>...<fileN>]
# This is a helper function typicaly used by asset install functions to copy their asset files to tree structure under a system folder.
# The nature of this helper function is that the relative path of the asset is preserved under the <dstPath>
# Params:
#    <type>    : the asset type. (e.g. cmd, bashLib, awkLib, manpage, etc...). This is the 2nd column of the manifest file
#    <pkgPath> : the path prefix of the asset in the project folder. This part of the asset path will not be reproduced in the <dstPath>
#    <dstPath> : the destination folder where assets of this type are installed. The asset path structure will be reproduced here
#    <fileN>   : filenames of assets of this type to install. Note that if no <fileN> are passed to this function, the manifest file
#                will be read to get the list of asset files to process.
# Options:
#    -z|--zipSpec=<regex> : Any <fileN> that matches this expression will be compressed into a .gz file instead of copied as is.
#                           '^' matches all files. The motivation was the doc folder where the changelog file needs to be
#                           compressed but other doc files do not.
#    -f|--flat : causes all files to be placed in the root of <dstPath> regardless of the relative path of the file in the project
function _installFilesToDst() {
	local zipSpec="^$" # default is to match no files
	local flatFlag recurseRmdir="-r" removePrefix
	while [ $# -gt 0 ]; do case $1 in
		-z*|--zipSpec*) bgOptionGetOpt val: zipSpec "$@" && shift ;;
		-f|--flat)  flatFlag="-f"; recurseRmdir="" ;;
		-r*|--removePrefix*) bgOptionGetOpt val: removePrefix "$@" && shift ;;
		*)  bgOptionsEndLoop "$@" && break; set -- "${bgOptionsExpandedOpts[@]}"; esac; shift;
	done

	local type="$1"; shift
	local pkgPath="$1"; shift
	local dstPath="${DESTDIR}$1"; shift

	local files=(); [ $# -eq 0 ] && { manifestReadOneType files "$type" || assertError; }
	for file in "$@" "${files[@]}"; do
		local dstFile="${dstPath}/${file#$pkgPath}"
		[ "$flatFlag" ] && dstFile="${dstPath}/${file##*/}"
		local dstFolder="${dstFile%/*}"
		[ ! -e "$dstFolder" ] && { $PRECMD mkdir -p "$dstFolder" || assertError; }

		if [[ "$file" =~ $zipSpec ]] && [[ ! "$file" =~ [.]gz$ ]]; then
			dstFile="${dstFile}.gz"
			gzip -n -f -9  < "$file" | $PRECMD tee "$dstFile" >/dev/null || assertError
		else
			$PRECMD cp "$file" "$dstFile" || assertError
		fi

		# write this asset to the HOSTMANIFEST
		printf "%-20s %-20s %s\n" "$pkgName" "$type" "${dstFile#${DESTDIR}}" | $PRECMD tee -a  $HOSTMANIFEST >/dev/null

		echo "rmFile $recurseRmdir '$dstFile' || assertError" | $PRECMD tee -a  "${UNINSTSCRIPT}" >/dev/null
	done
}




# Command manpage: bg-dev-install
# usage: bg-dev install [-v|-q] [--pkg=deb|rpm]
# usage: bg-dev uninstall [-v|-q] [--pkg=deb|rpm]
# copies the installable assets contained in a project into a destination file system tree.
# This install action is lower level than package manager installs. This is similar to the 'install' target in a project's makefile.
# When building a package for deb or rpm, this is used to create the staging file system tree that will go into the package file.
# A developer can also use this to install a project onto a host directly from its source folder for testing or for personal
# projects that are not meant for distribution.
#
# The default destination is the root filesystem of the host where it is running. The user will typically be prompted for their
# sudo password in that case. An uninstall script will be left in /var/lib/bg-core/<pkgName>/uninstall.sh. When invoked, it will
# undo all the actions done by install.
#
# The --pkg=<pkgType> option changes the destination file system tree to the project's .bglocal/pkgStaging-<pkgType> folder. .bglocal
# is a project subfolder that is ignored by get so development tools can use it as a project local temp folder.
#
# The <pkgType> may affect the structure of the destination filesystem as well its root path. When installing to the host filesystem,
# the <pkgType> is gleaned from the environment. The initial algorithm 1) if 'apt' is avaliable use 'deb' 2) if 'rpm' is available
# use 'rpm' 3) by default use 'deb'. The notion is that any OS distribution that supports apt will have a filesystem structure that
# complies with the debian package standard and likewise supporting rpm implies support for the Red Hat standard.
#
# Implementation:
# This function uses the manifest sub command to make sure that the project's manifest is up to date and then iterates over each
# asset type present in the manifest and calls a helper command based on the asset type and <pkgType>.
#
# Helper Commands:
# The helper commands follow a naming convention that allows common implementations across <pkgTypes> where appropriate and specific
# implementations when needed.
# These command names are tried, in order, until one is found.
#     bg-dev-install${assetType^}_${pkgType}   e.g. bg-dev-installBashCmd_deb
#     install${assetType^}_${pkgType}          e.g. installBashCmd_deb
#     bg-dev-install${assetType^}              e.g. bg-dev-installBashCmd
#     install${assetType^}                     e.g. installBashCmd
# The bg-dev-install* names would typically match external commands installed by some package and the install* names would typically
# match a builtin function or a function provided by a bgplugin
#
# Helper Runtime Environment:
# This is the environment that this function provides for helper functions that it invokes
#    working directory: the CWD/PWD is the root of the project's source folder. The DESTDIR may be relative to this so if you change
#                directory in your helper command, you need to take that into account
#    $1,$2,..$N : the files or folders of this asset type that are present in the project. The paths are relative to the project
#                 root
#    DESTDIR    : The root of the filesystem being installed to. If its empty, the installation goes to the real system folders on
#                 the host. The --pkg option changes it to the staging directory inside the package source folder
#    PRECMD     : This is typically either "" or "sudo " depending on whether the current user has access to write to DESTDIR
#                 helper functions should prefix comands that modify the DESTDIR filesystem with it like '$PRECMD cp $file $DESTDIR/...'
#                 This convention supports code that can install to the system folders using sudo or the pkgStaging folder without.
#    pkgName    : the name of the package being installed
#    UNINSTSCRIPT : path to the uninstall script that the helper should append to. Each action that the installer does to the DESTDIR
#                 should be represented by a command appended to this script that undoes that action. The uninstall script is typically
#                 not used by package managers but is used when installing/uninstalling to/from a host directly from the project
#                 folder.
#    HOSTMANIFEST : path to the host manifest file that is built during installation. Its similar to the package manifest but the
#                 files in the third column have the absolute path on the host instead of the relative path in the project folder.
#    manifestProjPath : contains the relative path from the project root of the manifest file. This is typicall not needed because
#                 the entries from this file that match the asset type are passed to the command as cmdline arguments.
#
# Uninstall:
# The companion subcommand 'uninstall' invokes the script created by the install subcommand. This can be useful if you install a
# project onto a host for testing and then want to remove it. You can give uninstall the same --pkg option that install takes to
# make it operate on the package staging folder but aside from testing to see if the uninstall script works, that is not very useful.
#
# Since uninstall only invokes the uninstall script left behind by the last install, it will remove correctly remove assets from the
# last installed version even when they no longer exist in the current project version being installed.
#
# The install subcommand will automatically invoke an uninstall script found in the DESTDIR to clean up DESTDIR before the new version
# is installed. This ensures that if you remove an asset, when you re-install the project, that asset will be removed from the DESTDIR
function install()
{
	local verbosity=${verbosity} DESTDIR dstSystem
	while [ $# -gt 0 ]; do case $1 in
		-v|--verbose) ((verbosity++)) ;;
		-q|--quiet) ((verbosity--)) ;;
		--pkg*)
			bgOptionGetOpt val: dstSystem "$@" && shift
			dstSystem="${dstSystem:-deb}"
			DESTDIR=".bglocal/pkgStaging-$dstSystem"
			;;
		*)  bgOptionsEndLoop "$@" && break; set -- "${bgOptionsExpandedOpts[@]}"; esac; shift;
	done
	[ ! "$dstSystem" ] && which apt &>/dev/null && dstSystem="deb"
	[ ! "$dstSystem" ] && which rpm &>/dev/null && dstSystem="rpm"
	[ ! "$dstSystem" ] && dstSystem="deb"

	[ "$DESTDIR" ] && [ ! -e "$DESTDIR/" ] && mkdir -p "$DESTDIR"
	local PRECMD; [ ! -w "$DESTDIR" ] && PRECMD="sudo "

	local UNINSTSCRIPT="${DESTDIR}/var/lib/bg-core/$pkgName/uninstall.sh"
	local HOSTMANIFEST="${DESTDIR}/var/lib/bg-core/$pkgName/hostmanifest"
	$PRECMD truncate -s0 "$HOSTMANIFEST"

	[ ${verbosity:-0} -ge 1 ] && printf "installing to %s\n" "${DESTDIR:-host filesystem}"

	export DESTDIR PRECMD UNINSTSCRIPT pkgName manifestProjPath
	#export -f manifestReadOneType bgOptionsEndLoop varSet printfVars varIsA

	# if there is a $UNINSTSCRIPT installed, call it to remove the last version before we install the current version.
	# this makes it clean when we remove or rename files in this library so that we dont leave obsolete files in the system
	[ -x "${UNINSTSCRIPT}" ] && { "${UNINSTSCRIPT}" || assertError -v UNINSTSCRIPT "
		The uninstall script from the previous installation ended with an error.
		You can edit that script to get around the error and try again. If you
		remove or rename that script this step will be skipped by the installer.
		There may or may not be steps in the uninstall script that need to complete
		before this package will install correctly so if you remove it, make a copy"; }

	### Start the $UNINSTSCRIPT script
	$PRECMD mkdir -p "${DESTDIR}/var/lib/bg-core/$pkgName"
	$PRECMD bash -c 'cat >"'"${UNINSTSCRIPT}"'"  <<-EOS
		#!/usr/bin/env bash
		#(its better to create a bespoke assertError) # [ -f /usr/lib/bg_core.sh ] && source /usr/lib/bg_core.sh
		[ "\$(type -t assertError)" != "function" ] && function assertError() {
		   printf "uninstall script failed: \n\tlocation:\$0(\${BASH_LINENO[0]})\n\tline: \$(awk 'NR=='"\${BASH_LINENO[0]}"'' \$0)\n"
		   exit 2
		}
		function rmFile() {
		   local recurseFlag; [ "\$1" == "-r" ] && { recurseFlag="-r"; shift; }
		   [ -e "\$1" ]        && { \$preUninstCmd rm -f "\$1" || return; }
		   [ "\$recurseFlag" ] && { \$preUninstCmd rmdir --ignore-fail-on-non-empty -p  "\${1%/*}" &>/dev/null; true; }
		   true
		}
		preUninstCmd=""; [ ! -w "\$0" ] && preUninstCmd="sudo "; true
		EOS' || assertError "error writing the initial uninstall script file contents"
	$PRECMD chmod a+x "${UNINSTSCRIPT}" || assertError

	manifestUpdate
	local -A types; manifestReadTypes types
	local type; for type in "${!types[@]}"; do
		assertNotEmpty type
		[ ${verbosity:-0} -ge 1 ] && printf "installing %4s %s\n" "${types[$type]}" "$type"
		local files=(); manifestReadOneType files "$type"
		local helperFnCandidatesNames="bg-dev-install${type^}_${dstSystem} install${type^}_${dstSystem} bg-dev-install${type^} install${type^}"
		local helperFnName found=''; for helperFnName in $helperFnCandidatesNames; do
			if which $helperFnName &>/dev/null || [ "$(type -t $helperFnName)" == "function" ]; then
				$helperFnName "${files[@]}"
				found="1"
				break;
			fi
		done
		[ "$found" ] || assertError -v helperFnCandidatesNames -v assetType:type -v pkgName "
			No install helper command found for asset type '${type^}'. You might need to install
			a plugin to handle this type of asset. This asset is listed in the project's .bglocal/manifest"
	done

	_installFilesToDst --flat manifest "" "/var/lib/bg-core/$pkgName" "$manifestProjPath"

	### Finish the $UNINSTSCRIPT script
	$PRECMD bash -c 'cat >>"'"${UNINSTSCRIPT}"'"  <<-EOS
		rmFile -r '${UNINSTSCRIPT}'
		true
		EOS' || assertError "error writing the final uninstall script file contents"
	$PRECMD chmod a+x "${UNINSTSCRIPT}"
}


# usage: bg-dev uninstall [-v|-q] [--pkg=deb|rpm]
function uninstall()
{
	local verbosity=${verbosity} DESTDIR dstSystem
	while [ $# -gt 0 ]; do case $1 in
		-v|--verbose) ((verbosity++)) ;;
		-q|--quiet) ((verbosity--)) ;;
		--pkg*)
			bgOptionGetOpt val: dstSystem "$@" && shift
			dstSystem="${dstSystem:-deb}"
			DESTDIR="${PWD}/.bglocal/pkgStaging-$dstSystem"
			;;
		*)  bgOptionsEndLoop "$@" && break; set -- "${bgOptionsExpandedOpts[@]}"; esac; shift;
	done
	[ "$DESTDIR" ] && [ ! -e "$DESTDIR/" ] && mkdir -p "$DESTDIR"
	local PRECMD; [ ! -w "$DESTDIR" ] && PRECMD="sudo "

	local UNINSTSCRIPT="${DESTDIR}/var/lib/bg-core/$pkgName/uninstall.sh"

	# if there is a $UNINSTSCRIPT installed, call it to remove the last version before we install the current version.
	# this makes it clean when we remove or rename files in this library so that we dont leave obsolete files in the system
	[ -x "${UNINSTSCRIPT}" ] && { "${UNINSTSCRIPT}" || assertError -v UNINSTSCRIPT "
		The uninstall script from the previous installation ended with an error.
		You can edit that script to get around the error and try again. If you
		remove or rename that script this step will be skipped by the installer.
		There may or may not be steps in the uninstall script that need to complete
		before this package will install correctly so if you remove it, make a copy"; }
}


# Command manpage: bg-dev-funcman
# usage: bg-dev funcman update [-v|-q] [--dry-run] [--compare] [-t|--templateFolder=<path>] [-o|--outputFolder=<path>]
# usage: bg-dev funcman test [-v|-q] <sourceFile>
# The name comes from shortening "function manpage". Now it creates other types of manpages from the source files as well as those
# for functions.
#
# Each bashLib in the project will have a man7 page generated and each bashCmd will have a man1 page. bashLib files will also
# produce a man3 page for any function that does not start with a '_' (a leading underscore indicates a private function)
#
# For any of these automatically generated manpages, the script author can provide additional content for that page in a comment
# block. For the bashCmd or bashLib page, the comment block is any contiguous block of un-indented comments that start with
# "# Command" or "# Library". For function manpages its the block of comments that immediately precede the function declaration
# and any alias function declarations.
#
# The code author can embed additional man pages by including a comment block starting with
# "# man(<n>.<type>) <pageName>" where <n>.<type> refers to a template named funcman.<n>.<type> in a profile folder or this project's
# data folder.
#
# Formatting:
#    See man(5) funcman -- documents the comment syntax supportted to create manpages
#
# Update Sub Command:
# The update sub command updates the generated manpages for the project that the command is running in. It will only update the
# timestamp on manpage files whose content has changed. Generated manpages reside in the .bglocal/funcman/ sub folder in the project
# It generates the current manpage content in a temporary folder. Then it compares those files with the ones in .bglocal/funcman.
# If neither the --dry-run or --compare options are specified it will go on to make the changes in .bglocal/funcman needed to make
# it be identical to the temporary folder. If --dry-run is specified, it will stop and print out the name of the temporary folder so
# that the user can inspect the contents. If --compare is specified, it will stop and open the two folders in the compare application
# registered for the user. See man(3) getUserCmpApp
# Update invokes the funcman_runBatch library function to do its work. See man(3) funcman_runBatch
#
# Test Sub Command:
# The test subcommand runs the funcman scanner a source file without generating the manpages but printing diagnostic information
# to stdout. This is typically used to confirm that the scanner is interpretting the source correctly to create the intended manpages.
# Add -v (verbsose) options to increase the printed diagnostics and -q (quiet) options to decrease it.
#
# ListTemplates Sub Command:
# Prints the names of the known funcman templates
#
# See Also:
#    man(7) bg_funcman.sh
#    man(3) getUserCmpApp
#    man(3) funcman_runBatch
#    man(3) funcman_testRun
function funcman() {
	local cmd="${1:-update}"; shift
	case ${cmd} in
		update)       funcman_runBatch       "$@" ;;
		test)		  funcman_testRun        "$@" ;;
		listTemplates) funcman_listTemplates "$@" ;;
		*) assertError -v cmd "unknown cmd" ;;
	esac
}


# Command manpage: bg-dev-tests
# usage: bg-dev tests list   [-f|--fullyQualyfied] [all]
#        bg-dev tests list   [-f|--fullyQualyfied] <utIDSpec> [...<utIDSpecN>]
# usage: bg-dev tests run    [-v|--verbose] [all]
#        bg-dev tests run    [-v|--verbose] <utIDSpec> [...<utIDSpecN>]
# usage: bg-dev tests report [-v|--verbose] [all]
#        bg-dev tests report [-v|--verbose] <utIDSpec> [...<utIDSpecN>]
# usage: bg-dev tests show   [-v|--verbose] [all]
#        bg-dev tests show   [-v|--verbose] <utIDSpec> [...<utIDSpecN>]
# This is the front end to the unit test framework for bg-core style pacakges. The terms unittest and testcase are used interchangably
# but in the future when different kinds of tests are possible we will have to be more precise.
#
# Testcases are identified by their utID. When a testcase is ran, it produces output to stdout that captures the entire state of its
# run. For example if it produces stderr output, that output is merged with stdout prefixed to indicate that it came from stderr.
# If a command exists with a non-zero exit code, a msg to that effect will be written to stdout.
#
# The testcase is considered to have passed if the output it produces is logically equivalant to the expected output that is committed
# to the project's repo. That saved, expected output is called the 'plato' output as a nod to the philosopher's ideas. Lines that
# start with # or // are not considered part of the logical output. Those lines can be useful to humans understanding the output.
#
# There are two steps to controlling the behavior of a package through its testcases. First is editting the plato data to ensure
# that it represents the desired functionality. Second is developing the source code so that the code that is the target of a test
# produces that output. In practice, a test case author typically writes a new test, observeres the output and if it produces the
# output that is considered correct, copies that actaul output to the plato data.
#
# After the initall plato data is set, from that point on, the testcase will monitor if anything changes the expected output. If
# so, the testcase fails and someone decides if the code needs to change to keep the expected behaior the same, or if the plato
# data should change to document that the expected behavior is now different.  The git history of the plato data is the history of
# how the project's behavior (which could be an API) has evolved over time.
#
# A good testcase will output to un-commented lines, only information that is relavent to the target of the test functioning as required
# deviod of arbitrary information that would not affect whether the target is working correctly. That way the testcase will only
# break when a significant change in behavior happens.
#
# run sub command:
# exectues the specified testcases, updates the saved data and reportes on the outcome. Run reports on two things. First is whether
# each testcase produced new, updated, or unchanged output relative to the last time it was ran. Second is whether each test case
# passed, failed, had a setup error, or is missing plato data which means that it is uninitialized.
#
# list sub command:
# prints the utID for each testcase that matches the <utIDSpec> specified.
#
# report sub command:
# produces similar output as the run command by using the previous run data instead of runing the testcases. The modification
# information is supressed since it is all unchanged.
#
# See Also:
#    man(1) bg-unitTests.ut
function testsCntr()
{
	local cmd="${1:-list}"; shift
	case ${cmd} in
		list)       utfList       "$@" ;;
		run)		utfRun        "$@" ;;
		report)     utfReport     "$@" ;;
		show)       utfShow       "$@" ;;
		parse)      utfIDParse -t "$@" ;;
		*) assertError -v cmd "unknown cmd" ;;
	esac
}


###############################################################################
# Main script

# default values for parameters
command=""
verbosity=1
oob_invokeOutOfBandSystem "$@"
while [ $# -gt 0 ]; do case $1 in
	-v|--verbose) ((verbosity++)) ;;
	-q|--quiet) ((verbosity--)) ;;
	--verbosity*) bgOptionGetOpt val: verbosity "$@" && shift ;;
	*)  bgOptionsEndLoop "$@" && break; set -- "${bgOptionsExpandedOpts[@]}"; esac; shift;
done
command="$1"; shift

baseDir="$(pwd)"

[ ! -f .bg-sp/config ] && assertError "This does not appear to be a bg-dev project folder because there is no .bg-sp/config file"

pkgName="$(iniParamGet ".bg-sp/config" . packageName)"
assertNotEmpty pkgName ".bg-sp/config does not contain a packageName=<name> setting"

[ -f "${baseDir}/.bg-sp/config" ] || assertError "This '$pkgName' folder does not appear to be a bgproject folder"


case ${command:-show} in
	manifest)      manifest   "${passThruOpts[@]}" "$@" ;;
	install)       install    "${passThruOpts[@]}" "$@" ;;
	uninstall)     uninstall  "${passThruOpts[@]}" "$@" ;;
	funcman)       funcman    "${passThruOpts[@]}" "$@" ;;
	tests)         testsCntr  "${passThruOpts[@]}" "$@" ;;
	show)          manifest summary  ;;
	*)  echo "error: unknown command '$command'. "
		echo "   See man $(basename $0)"
		;;
esac
