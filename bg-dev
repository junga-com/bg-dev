#!/usr/bin/env bash

###############################################################################
# Includes and defines

projectName=bg-dev

source /usr/lib/bg_core.sh
import bg_ini.sh ;$L1;$L2

supportedCmds="manifest install ctags"
manifestProjPath=".bglocal/manifest"

###############################################################################
# Functions

# this is invoked by invokeOutOfBandSystem when -hb is the first param
# The bash completion script calls this get the list of possible words.
function printBashCompletion()
{
	local words cword cur prev optWords posWords posCwords
	parseForBashCompletion --compat2 words cword cur prev optWords posWords posCwords "$@"

	cmd="${posWords[1]}"

	case $cmd:$posCwords in
		*:1) echo $supportedCmds ;;
		manifest:2) echo "print update summary" ;;
	esac
	exit
}

# Use this function to provide the BC suggestions for (-?) options that require parameters
# see man bg-overviewOutOfBandScriptFunctions for details
function oob_printOptBashCompletion()
{
	local opt="$1"
	local cur="$2"
	case $opt in
		x) : ;;
	esac
}

# Use this function to provide BC suggestions for positional parameters
# see man bg-overviewOutOfBandScriptFunctions for details
function oob_helpMode()
{
	local words cword cur prev optWords posWords posCwords
	parseForBashCompletion --compat2 words cword cur prev optWords posWords posCwords "$@"

	local cmd="${posWords[1]}"
	case ${cmd:-main} in
		main)  man "$(basename $0)" ;;
		*)     man "$(basename $0)" ;;
	esac
}


function manifestBuild()
{
	local -A fileList=();

	function _printManifest() {
		local pkgName="$1"
		local type="$2"
		for filename in "${!fileList[@]}"; do
			printf "%-20s %-13s %s\n" "$pkgName" "$type"  "$filename"
		done
	}

	# commands are executables without an extension in the project root folder.
	fileList=();
	fsExpandFiles -S fileList * -perm /a+x -type f ! -name "*.*" ! -name Makefile
	_printManifest "$pkgName" "cmd"

	# Bash libraries are any file with .sh extension
	fileList=();
	bgfind -S fileList *  -type f   -name "*.sh"
	_printManifest "$pkgName" "bashLib"

	# any *.awk file is an awk library file regardless of what folder it is in.
	fileList=();
	bgfind -S fileList *  -type f  -name "*.awk"
	_printManifest "$pkgName" "awkLib"

	fileList=();
	bgfind -S fileList unitTests/* -perm /a+x -name "*.ut" -type f
	_printManifest "$pkgName" "unitTest"

	fileList=();
	bgfind -S fileList man[1-9] -path "man*/*.[1-9]*" -type f
	_printManifest "$pkgName" "manpage"

	fileList=();
	bgfind -S fileList etc/ -type f
	_printManifest "$pkgName" "etc"

	fileList=();
	bgfind -S fileList opt/ -type f
	_printManifest "$pkgName" "opt"

	fileList=();
	bgfind -S fileList data/ -type f
	_printManifest "$pkgName" "data"

	fileList=();
	bgfind -S fileList doc/ -type f
	_printManifest "$pkgName" "doc"

	fileList=();
	bgfind -S fileList cron.d/ -type f
	_printManifest "$pkgName" "cron"

	fileList=();
	bgfind -S fileList init.d/ -type f
	_printManifest "$pkgName" "sysVinit"

	fileList=();
	bgfind -S fileList systemd/ -type f
	_printManifest "$pkgName" "sysDInit"

	fileList=();
	bgfind -S fileList rsyslog.d/ -type f
	_printManifest "$pkgName" "syslog"

	# TODO: consider using the naming patterns from the .bg-sp/config file as a lint to double check the manifest and warn for non-compliance
	# libPattern="$(iniParamGet "${baseDir}/.bg-sp/config" . libPattern)"
	# cmdPattern="$(iniParamGet "${baseDir}/.bg-sp/config" . cmdPattern)"
	# libsToInstall="$(find -L "$baseDir" -name "bg_*.sh" -printf "%P\n")"
	# cmdsToInstall="$(find -L "$baseDir" -name "bg-*"    -printf "%P\n")"
}

### define the built-in helper functions for all the known asset types discovered in the builtin manifestBuild function
# note that a install* function does not have to use installFileTypeToDestinationTree. It can do anything it wants to represent its
# assets in the destination file system. See installFileTypeToDestinationTree as a model to build a custom one.
function installUnitTest()   { : ; } # unittests are not installed
#                                                                                  <type>      <pkgPath>      <dstPath>
function installCmd()        { installFileTypeToDestinationTree --flat             "cmd"       ""             "/usr/bin"; }
function installBashLib()    { installFileTypeToDestinationTree --flat             "bashLib"   ""             "/usr/lib"; }
function installAwkLib()     { installFileTypeToDestinationTree --flat             "awkLib"    ""             "/usr/share/awk"; }
function installEtc()        { installFileTypeToDestinationTree                    "etc"       "etc/"         "/etc"; }
function installOpt()        { installFileTypeToDestinationTree                    "opt"       "opt/"         "/opt"; }
function installData()       { installFileTypeToDestinationTree                    "data"      "data/"        "/usr/share/$pkgName"; }
function installDoc()        { installFileTypeToDestinationTree -z "doc/changelog" "doc"       "doc/"         "/usr/share/$pkgName"; }
function installManpage()    { installFileTypeToDestinationTree -z "^"             "manpage"   ""             "/usr/share/man"; }
function installCron()       { installFileTypeToDestinationTree                    "cron"      "cron.d/"      "/etc/cron.d"; }
function installSysVInit()   { installFileTypeToDestinationTree                    "sysVInit"  "init.d/"      "/etc/init.d"; }
function installSysDInit()   { installFileTypeToDestinationTree                    "sysDInit"  "systemd/"     "/etc/systemd/system/"; }
function installSyslog()     { installFileTypeToDestinationTree                    "syslog"    "rsyslog.d/"   "/etc/rsyslog.d/"; }


function manifestSummary()
{
	manifestBuild | awk '
		{
			pkg=$1; type=$2; file=$3
			types[pkg][type]++
		}
		END {
			for (pkg in types) {
				printf("%s\n", pkg)
				for (type in types[pkg]) {
					printf("   %4s %s\n", types[pkg][type], type)
				}
			}
		}
	'
}

function manifestUpdate()
{
	local verbosity=${verbosity}
	while [ $# -gt 0 ]; do case $1 in
		-v|--verbose) ((verbosity++)) ;;
		-q|--quiet) ((verbosity--)) ;;
		*)  bgOptionsEndLoop "$@" && break; set -- "${bgOptionsExpandedOpts[@]}"; esac; shift;
	done

	local tmpFile="$(mktemp)"
	manifestBuild | sort > "$tmpFile"
	if [ ! -e $manifestProjPath ] || ! diff -q "$tmpFile" "$manifestProjPath" >/dev/null; then
		[ ! -e "${manifestProjPath%/*}" ] && mkdir -p "${manifestProjPath%/*}"
		cat "$tmpFile" > $manifestProjPath
		[ ${verbosity:-0} -ge 1 ] && echo "$manifestProjPath was updated"
		rm "$tmpFile"
		return 0
	fi
	[ ${verbosity:-0} -ge 1 ] && echo "$manifestProjPath is already up to date"
	rm "$tmpFile"
	return 1
}

function manifest()
{
	local verbosity=${verbosity}
	while [ $# -gt 0 ]; do case $1 in
		-v|--verbose) ((verbosity++)) ;;
		-q|--quiet) ((verbosity--)) ;;
		*)  bgOptionsEndLoop "$@" && break; set -- "${bgOptionsExpandedOpts[@]}"; esac; shift;
	done

	local mode="$1"; shift

	case ${mode:-print} in
		print)   manifestBuild "$@" ;;
		update)  manifestUpdate "$@" ;;
		summary) manifestSummary "$@" ;;
	esac
}

function manifestReadTypes()
{
	local manifestFile="$manifestProjPath"
	while [ $# -gt 0 ]; do case $1 in
		-f*|--file*) bgOptionGetOpt val: manifestFile "$@" && shift ;;
		*)  bgOptionsEndLoop "$@" && break; set -- "${bgOptionsExpandedOpts[@]}"; esac; shift;
	done

	local typesVar="$1"
	local type count
	while read -r type count; do
		[ "$type" == "<error>" ] && assertError "There is no manifest file for package '$pkgName' at the expected location"
		mapSet $typesVar "$type" "$count"
	done < <(awk '
		{types[$2]++}
		END {
			for (type in types)
				printf("%s %s\n", type, types[type])
		}
	' "$manifestFile" || echo '<error>')
}

function manifestReadOneType()
{
	local manifestFile="$manifestProjPath"
	while [ $# -gt 0 ]; do case $1 in
		-f*|--file*) bgOptionGetOpt val: manifestFile "$@" && shift ;;
		*)  bgOptionsEndLoop "$@" && break; set -- "${bgOptionsExpandedOpts[@]}"; esac; shift;
	done

	local filesVar="$1"
	local type="$2"

	local file
	while read -r file; do
		varSet "$filesVar[$((i++))]" "$file"
	done < <(awk -v type="$type" '
		$2==type {print $3}
	' "$manifestFile")
}


# usage: installFileTypeToDestinationTree <type> <pkgPath> <dstPath> [<file1>...<fileN>]
# This is a helper function typicaly used by asset install functions to copy their asset files to tree structure under a system folder.
# The nature of this helper function is that the relative path of the asset is preserved under the <dstPath>
# Params:
#    <type>    : the asset type. (e.g. cmd, bashLib, awkLib, manpage, etc...). This is the 2nd column of the manifest file
#    <pkgPath> : the path prefix of the asset in the project folder. This part of the asset path will not be reproduced in the <dstPath>
#    <dstPath> : the destination folder where assets of this type are installed. The asset path structure will be reproduced here
#    <fileN>   : filenames of assets of this type to install. Note that if no <fileN> are passed to this function, the manifest file
#                will be read to get the list of asset files to process.
function installFileTypeToDestinationTree() {
	local zipSpec="^$" # default is to match no files
	local flatFlag recurseRmdir="-r"
	while [ $# -gt 0 ]; do case $1 in
		-z*|--zipSpec*) bgOptionGetOpt val: zipSpec "$@" && shift ;;
		-f|--flat)  flatFlag="-f"; recurseRmdir="" ;;
		*)  bgOptionsEndLoop "$@" && break; set -- "${bgOptionsExpandedOpts[@]}"; esac; shift;
	done

	local type="$1"; shift
	local pkgPath="$1"; shift
	local dstPath="${DESTDIR}$1"; shift

	local files=(); [ $# -eq 0 ] && { manifestReadOneType files "$type" || assertError; }
	for file in "$@" "${files[@]}"; do
		local dstFile="${dstPath}/${file#$pkgPath}"
		[ "$flatFlag" ] && dstFile="${dstPath}/${file##*/}"
		local dstFolder="${dstFile%/*}"
		[ ! -e "$dstFolder" ] && { $PRECMD mkdir -p "$dstFolder" || assertError; }

		if [[ "$file" =~ $zipSpec ]] && [[ ! "$file" =~ [.]gz$ ]]; then
			dstFile="${dstFile}.gz"
			gzip -n -f -9  < "$file" | $PRECMD tee "$dstFile" >/dev/null || assertError
		else
			$PRECMD cp "$file" "$dstFile" || assertError
		fi

		echo "rmFile $recurseRmdir '$dstFile' || assertError" | $PRECMD tee -a  "${uninstScript}" >/dev/null
	done
}




# This function sets up the install environment and then calls help functions registered to handle each of the assert types found
# the pkg manifest file to do the real work of installing each asset
# Environment:
# This is the environment that this function provides for helper functions that it invokes
#    DESTDIR   : The root of the filesystem being installed to. If its empty, the installation goes to the real system folders on
#                the host. The --pkg option changes it to the staging directory inside the package source folder
#    PRECMD    : This is typically either "" or "sudo " depending on whether the current user has access to write to DESTDIR
#                helper functions should prefix comands that modify the DESTDIR filesystem with it like '$PRECMD cp $file $DESTDIR/...'
#    pkgName   : the name of the package being installed
function install()
{
	local verbosity=${verbosity}
	while [ $# -gt 0 ]; do case $1 in
		-v|--verbose) ((verbosity++)) ;;
		-q|--quiet) ((verbosity--)) ;;
		--pkg) local DESTDIR="${PWD}/.bglocal/pkgStaging" ;;
		*)  bgOptionsEndLoop "$@" && break; set -- "${bgOptionsExpandedOpts[@]}"; esac; shift;
	done
	[ "$DESTDIR" ] && [ ! -e "$DESTDIR/" ] && mkdir -p "$DESTDIR"
	local PRECMD; [ ! -w "$DESTDIR" ] && PRECMD="sudo "

	local uninstScript="${DESTDIR}/var/lib/bg-dev/$pkgName/uninstall.sh"

	# if there is a $uninstScript installed, call it to remove the last version before we install the current version.
	# this makes it clean when we remove or rename files in this library so that we dont leave obsolete files in the system
	[ -x "${uninstScript}" ] && { "${uninstScript}" || assertError -v uninstScript "
		The uninstall script from the previous installation ended with an error.
		You can edit that script to get around the error and try again. If you
		remove or rename that script this step will be skipped by the installer.
		There may or may not be steps in the uninstall script that need to complete
		before this package will install correctly so if you remove it, make a copy"; }

	### Start the $uninstScript script
	$PRECMD mkdir -p "${DESTDIR}/var/lib/bg-dev/$pkgName"
	$PRECMD bash -c 'cat >"'"${uninstScript}"'"  <<-EOS
		#!/usr/bin/env bash
		[ -f /usr/lib/bg_core.sh ] && source /usr/lib/bg_core.sh
		[ "\$(type -t assertError)" != "function" ] && function assertError() {
		   printf "uninstall script failed: \n\tlocation:\$0(\${BASH_LINENO[0]})\n\tline: \$(awk 'NR=='"\${BASH_LINENO[0]}"'' \$0)\n"
		   exit 2
		}
		function rmFile() {
		   local recurseFlag; [ "\$1" == "-r" ] && { recurseFlag="-r"; shift; }
		   [ -e "\$1" ]        && { \$preUninstCmd rm -f "\$1" || return; }
		   [ "\$recurseFlag" ] && { rmdir --ignore-fail-on-non-empty -p  "\${1%/*}" || return; }
		   true
		}
		preUninstCmd=""; [ ! -w "\$0" ] && preUninstCmd="sudo "
		EOS' || assertError "error writing the initial uninstall script file contents"
	$PRECMD chmod a+x "${uninstScript}" || assertError

	manifestUpdate
	local -A types; manifestReadTypes types
	local type; for type in "${!types[@]}"; do
		[ ${verbosity:-0} -ge 1 ] && printf "installing %4s %s\n" "${types[$type]}" "$type"
		if [ "$(type -t install${type^})" == "function" ]; then
			install${type^}
		else
			assertError "Do not know how to install asset type '${type^}'. You might need to install a plugin"
		fi
	done

	installFileTypeToDestinationTree --flat manifest "" "/var/lib/bg-dev/$pkgName" "$manifestProjPath"

	### Finish the $uninstScript script
	$PRECMD bash -c 'cat >>"'"${uninstScript}"'"  <<-EOS
		rmFile -r '${uninstScript}'
		true
		EOS' || assertError "error writing the final uninstall script file contents"
	$PRECMD chmod a+x "${uninstScript}"
}

function uninstall()
{
	local verbosity=${verbosity}
	while [ $# -gt 0 ]; do case $1 in
		-v|--verbose) ((verbosity++)) ;;
		-q|--quiet) ((verbosity--)) ;;
		--pkg) local DESTDIR="${PWD}/.bglocal/pkgStaging" ;;
		*)  bgOptionsEndLoop "$@" && break; set -- "${bgOptionsExpandedOpts[@]}"; esac; shift;
	done
	[ "$DESTDIR" ] && [ ! -e "$DESTDIR/" ] && mkdir -p "$DESTDIR"
	local PRECMD; [ ! -w "$DESTDIR" ] && PRECMD="sudo "

	local uninstScript="${DESTDIR}/var/lib/bg-dev/$pkgName/uninstall.sh"

	# if there is a $uninstScript installed, call it to remove the last version before we install the current version.
	# this makes it clean when we remove or rename files in this library so that we dont leave obsolete files in the system
	[ -x "${uninstScript}" ] && { "${uninstScript}" || assertError -v uninstScript "
		The uninstall script from the previous installation ended with an error.
		You can edit that script to get around the error and try again. If you
		remove or rename that script this step will be skipped by the installer.
		There may or may not be steps in the uninstall script that need to complete
		before this package will install correctly so if you remove it, make a copy"; }
}

function ctagsBuild() {
	ctags -R --extra=+f --exclude="*.bglocal/*" --exclude="*node_modules/*"
	sed -i -E '/^(if|switch|function|module\.exports|it|describe).+language:js$/d' tags
}

###############################################################################
# Input handling

# default values for parameters
command=""
verbosity=1

invokeOutOfBandSystem "$@"
while [ $# -gt 0 ]; do case $1 in
	-v|--verbose) ((verbosity++)) ;;
	-q|--quiet) ((verbosity--)) ;;
	*)  bgOptionsEndLoop "$@" && break; set -- "${bgOptionsExpandedOpts[@]}"; esac; shift;
done

###############################################################################
# Main script

command="$1"; shift

baseDir="$(pwd)"

[ ! -f .bg-sp/config ] && assertError "This does not appear to be a bg-dev project folder because there is no .bg-sp/config file"

pkgName="$(iniParamGet ".bg-sp/config" . packageName)"
assertNotEmpty pkgName ".bg-sp/config does not contain a packageName=<name> setting"

[ -f "${baseDir}/.bg-sp/config" ] || assertError "This '$pkgName' folder does not appear to be a bgproject folder"


case ${command:-list} in
	ctags)         ctagsBuild "${passThruOpts[@]}" "$@" ;;
	manifest)      manifest   "${passThruOpts[@]}" "$@" ;;
	install)       install    "${passThruOpts[@]}" "$@" ;;
	uninstall)     uninstall  "${passThruOpts[@]}" "$@" ;;
	*)  echo "error: unknown command '$command'. "
		echo "   See man $(basename $0)"
		;;
esac
