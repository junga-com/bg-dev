#!/usr/bin/env bash

# The goal of this configure script is...
#     1) install the bash headers and loadable builtin Makefile.inc. On debian based distros this is the bash-builtins pacakge.
#     2) locate the builtin Makefile.inc. On debian based distros this is at /usr/lib/bash/Makefile.inc
#     3) copy that Makefile.inc to this project folder as Makefile and modify it to replace the example.c builtin target with
#        the builtin taget(s) contained in this project. The deps.awk script produces explicit rules for all code in the project.
#

# this is a space separated list of folders where a distro might place the loadable builtin makefile.
# it might alsways be /usr/lib/bash but just in case your distro does it differently, here is the place to add that info
pathsToTry="/usr/lib/bash"

function assertError() {
	echo "$*" >&2
	exit 2
}

# fills in var 'makefileLocation' if succesful
function searchForMakefile() {
	for pathToTry in /usr/lib/bash; do
		if [ -f "${pathToTry}"/Makefile.inc ]; then
			makefileLocation="${pathToTry}"/Makefile.inc
			break
		fi
	done
}

# To support a new distro, add a new elif block for that distro's package manager command to install the package contained in $1
function installDependency() {
	echo "installing dependency '$1'"
	if type -t apt-get &>/dev/null; then
		sudo apt-get install -y "$1"
	# elif type -t yum &>/dev/null; then
	# 	yum install -y "$1"
	else
		cat <<-EOS
			This distro is not yet supported by this configure script because it does not know how to install the dependency
			'$1' You can manually install that dependency and then re-run this command.
			EOS
	fi
}

# allow the caller to provide the path to the Makefile.inc
if [ "$1" ]; then
	makefileLocation="${1%/Makefile.inc}/Makefile.inc"
	[ -f "$makefileLocation" ] || {
		assertError "The Makefile.inc location provided as the first argument does not exist" >&2
	}
else
	searchForMakefile
fi

# if not found, try to install the bash builts/headers
[ -f "$makefileLocation" ] || {
	installDependency bash-builtins
	searchForMakefile
}

# if still not found, error out
[ -f "$makefileLocation" ] || {
	assertError <<-EOS
		Could not find the bash loadable builtin Makefile.inc on this host which is needed to build this project.
		You can manually install the bash-builtin/headers from a package from your distro or by downloading and builing the bash
		source and then re-run this command.

		If the builtins Makefile is not installed to /usr/lib/Makefile.inc, pass the full path to it as the first argument to
		this command.
		EOS
}

# try to install awk if its missing
type -t awk &>/dev/null || installDependency awk
type -t awk &>/dev/null || assertError "This command needs 'awk' to modify the Makefile.inc from the bash project to become this project's makefile"


# the .c files in the root of this project will build into .so files
builtinList="$(ls -1 *.c 2>/dev/null)"
[ "$builtinList" ] || {
	assertError "No <builtin>.c files found in this project. It is assumed that <builtin>.c will be in the root project folder"
}

# the .c files in ./lib/ folder will build into .o which will link into all the .so (at this time there is no way an .so can declare
# which support libraries it needs)
libraryList="$(ls -1 lib/*.c 2>/dev/null)"



# This makeScript will replace the bottom of the examples/loadables/Makefile.inc which contains the example.c targets.
makeScript='
##################################################################################################################################
# Start of project specific section
#    The makefile before this line was copied from %makefileLocation%
#    This makefile is generated by ./configure
#
# General Strategy:
#    Builtin code files:
#       .c files in the project root
#    Modules used by builtin code:
#       .c and .h files in the ./lib/ folder
#
#    all .c files (builtin code and modules) build to ./bin/obj/*.o files using the same recipe
#    builtin .so files are built into the ./bin/*.so folder
#
# deps.awk:
#    The deps.awk script is passed all the .c and .h files in the project and writes out the explicit Makefile rules for the project
#    in the section below. The script assumes that .c files in the root of the project are loadable builtins and .c files in ./lib/
#    folder are modules used by the builtin code.

INC += -I./lib
INC += -I./includeTemp

VPATH = .:lib

# the <builtinName>.so output files will be placed in the $(BIN) folder.
# the intermediate <builtinName>.o files will be placed in the $(OBJ) folder.
BIN = bin/
OBJ = bin/obj/
INSTALLDIR = $(DESTDIR)/usr/lib/bash

BUILTIN_FILES = %builtinSOList%
LIBMODULES = %libModulesList%

# tell make to forget all of its default implicit rules. we want to specify the cmdline for everything we build
# and tell make to run the entire recipe as one script
.SUFFIXES:
.ONESHELL:

all: $(OBJ) $(BIN) $(BUILTIN_FILES)

# These are the actuall dynamic dependencies for this project produced by deps.awk
'$(awk -i deps.awk '' *.c lib/*.c lib/*.h)'


$(BIN) $(OBJ) $(INSTALLDIR) :
	mkdir -p $@

clean:
	-@$(RM) $(OBJ)*.o  $(BIN)*.so lib/*.o
	rmdir bin 2>/dev/null

install: $(INSTALLDIR) all
	prefixCmd=""; [ ! -w "$(INSTALLDIR)" ] && prefixCmd="sudo "
	$$prefixCmd cp  $(BUILTIN_FILES) $(INSTALLDIR)

.DELETE_ON_ERROR:
.PHONEY: all clean install
'



# copy and modify the Makefile.inc
echo "$builtinList" | awk -v makeScript="$makeScript" -v makefileLocation="$makefileLocation" -v libraryListStr="$libraryList" '
	@include "bg_core.awk"
	BEGIN {
		printf("# WARNING: This file is overwritten each time you run ./configure so you probably dont want to edit it directly \n");
		while ((getline builtinSource <"/dev/stdin") >0) {
			builtinList[builtinSource]=1
		}
		split(libraryListStr,tmp)
		for (i in tmp)
			libraryList[tmp[i]]=""

		# set these equal to the cmdline from the ".c.o:" and "example:" targets respectively from the /usr/lib/bash/Makefile.inc
		# if they change
		origCompilerCommand="	$(SHOBJ_CC) $(SHOBJ_CFLAGS) $(CCFLAGS) $(INC) -c -o $@ $<";
		linkerCommand="	$(SHOBJ_LD) $(SHOBJ_LDFLAGS) $(SHOBJ_XLDFLAGS) -o $@ example.o $(SHOBJ_LIBS)";
	}

	# capture all lines up until the targets that we will replace
	# assume that all: is still at the bottom and that it and everything below it is specific to the example.c builtin (that we will remove)
	$1=="all:"  {stopCopying=NR}
	$1==".c.o:" {stopCopying=NR}
	$1~/^[^[:space:]]+[[:space:]]?:[^=]/ {stopCopying=NR}
	stopCopying=="" {origLines[NR]=$0}

	# its ok if the input Makefile.inc no longer has this target but if it does, we print a warning if it has changed
	# catpure the build command for the building example: from example.o so that we can modify it to be general (an implicit rule)
	$1==".c.o:" {
		getline
		if (origCompilerCommand != $0)
			printf("WARNING: the compiler %s command under the '%s' target has changed since this configure script was written. You may need to update the '%s' rule in ./configure \n", "build", $1, "%.o : %.c") > "/dev/stdout"
		origCompilerCommand=$0
	}

	# its ok if the input Makefile.inc no longer has this target but if it does, we print a warning if it has changed
	# catpure the build command for the building example: from example.o so that we can modify it to be general (an implicit rule)
	$1=="example:" {
		getline
		if (linkerCommand != $0)
			printf("WARNING: the %s build command under the '%s' target has changed since this configure script was written. You may need to update the '%s' rule in ./configure \n", "linker", $1, "$(BIN)%.so : %.o") > "/dev/stdout"
		linkerCommand=$0
	}

	END {
		# these commands come from the original Makefile.inc but we need to fixup the input/output to be generic and in the $(OBJ) folder
		soCompilerCommand=gensub(/[$][@]/,   "$(OBJ)$@", "g",origCompilerCommand);
		compilerCommand=gensub(/[$][(]SHOBJ_CFLAGS[)]/, "", "g",soCompilerCommand);
		linkerCommand  =gensub(/example.o/,"$(OBJ)$<", "g",linkerCommand);

		makeScript=gensub(/%soCompilerCommand%/,soCompilerCommand,"g",makeScript);
		makeScript=gensub(/%compilerCommand%/,compilerCommand,"g",makeScript);
		makeScript=gensub(/%linkerCommand%/,  linkerCommand,  "g",makeScript);

		makeScript=gensub(/%makefileLocation%/,  makefileLocation,  "g",makeScript);


		builtinSOList=""
		for (builtinName in builtinList)
			builtinSOList=builtinSOList" $(BIN)"gensub(/[.]c$/,".so","g",builtinName)
		makeScript=gensub(/%builtinSOList%/,  builtinSOList,  "g",makeScript);

		libModulesList=""
		for (moduleName in libraryList) {
			moduleName=gensub(/[.]c$/,".o","g",moduleName)
			moduleName=gensub(/^lib\//,"","g",moduleName)
			libModulesList=libModulesList" $(OBJ)"moduleName
		}
		makeScript=gensub(/%libModulesList%/,  libModulesList,  "g",makeScript);


		# if the Makefile.inc no longer has an explicit all: rule, then we can use it as a an include file.
		if (!stopCopying) {
			printf("\ninclude %s\n\n", FILENAME);

		# otherwise, copy the original Makefile.inc up to the point that it starts defining the targets
		} else {
			for (i=0; i<=stopCopying; i++)
				printf("%s\n",origLines[i]);
		}

		# print our script at the end
		printf("%s\n", makeScript);
	}
' "$makefileLocation" > ./Makefile
result=$?

if [ $result -ne 0 ]; then
	assertError <<-EOS
		the awk command that modifies '$makefileLocation' to become './Makefile' exited with the error code '$result'.
		You can try to copy and modify that Makefile yourself. Typically search and replace the 'example' builtin with the
		name of the built(s) from this project.
		EOS
else
	echo "Success"
fi
echo
